{"version":3,"file":"js/982.8de65587.js","mappings":"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","sources":["webpack://portfolio/./src/views/ArticleView.vue?6c83","webpack://portfolio/./node_modules/marked/lib/marked.esm.js","webpack://portfolio/src/views/ArticleView.vue","webpack://portfolio/./src/views/ArticleView.vue?2c3e","webpack://portfolio/./src/views/ArticleView.vue","webpack://portfolio/./src/assets/articles/helloworld.md","webpack://portfolio/./src/constants.js","webpack://portfolio/ ^\\.\\/.*$"],"sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticStyle:{\"text-align\":\"left\"}},[_c('div',{attrs:{\"id\":\"article\"},domProps:{\"innerHTML\":_vm._s(_vm.markdownToHtml)}})])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","/**\n * marked - a markdown parser\n * Copyright (c) 2011-2022, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n\nfunction getDefaults() {\n  return {\n    baseUrl: null,\n    breaks: false,\n    extensions: null,\n    gfm: true,\n    headerIds: true,\n    headerPrefix: '',\n    highlight: null,\n    langPrefix: 'language-',\n    mangle: true,\n    pedantic: false,\n    renderer: null,\n    sanitize: false,\n    sanitizer: null,\n    silent: false,\n    smartLists: false,\n    smartypants: false,\n    tokenizer: null,\n    walkTokens: null,\n    xhtml: false\n  };\n}\n\nlet defaults = getDefaults();\n\nfunction changeDefaults(newDefaults) {\n  defaults = newDefaults;\n}\n\n/**\n * Helpers\n */\nconst escapeTest = /[&<>\"']/;\nconst escapeReplace = /[&<>\"']/g;\nconst escapeTestNoEncode = /[<>\"']|&(?!#?\\w+;)/;\nconst escapeReplaceNoEncode = /[<>\"']|&(?!#?\\w+;)/g;\nconst escapeReplacements = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;'\n};\nconst getEscapeReplacement = (ch) => escapeReplacements[ch];\nfunction escape(html, encode) {\n  if (encode) {\n    if (escapeTest.test(html)) {\n      return html.replace(escapeReplace, getEscapeReplacement);\n    }\n  } else {\n    if (escapeTestNoEncode.test(html)) {\n      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n    }\n  }\n\n  return html;\n}\n\nconst unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n\n/**\n * @param {string} html\n */\nfunction unescape(html) {\n  // explicitly match decimal, hex, and named HTML entities\n  return html.replace(unescapeTest, (_, n) => {\n    n = n.toLowerCase();\n    if (n === 'colon') return ':';\n    if (n.charAt(0) === '#') {\n      return n.charAt(1) === 'x'\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\n        : String.fromCharCode(+n.substring(1));\n    }\n    return '';\n  });\n}\n\nconst caret = /(^|[^\\[])\\^/g;\n\n/**\n * @param {string | RegExp} regex\n * @param {string} opt\n */\nfunction edit(regex, opt) {\n  regex = typeof regex === 'string' ? regex : regex.source;\n  opt = opt || '';\n  const obj = {\n    replace: (name, val) => {\n      val = val.source || val;\n      val = val.replace(caret, '$1');\n      regex = regex.replace(name, val);\n      return obj;\n    },\n    getRegex: () => {\n      return new RegExp(regex, opt);\n    }\n  };\n  return obj;\n}\n\nconst nonWordAndColonTest = /[^\\w:]/g;\nconst originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;\n\n/**\n * @param {boolean} sanitize\n * @param {string} base\n * @param {string} href\n */\nfunction cleanUrl(sanitize, base, href) {\n  if (sanitize) {\n    let prot;\n    try {\n      prot = decodeURIComponent(unescape(href))\n        .replace(nonWordAndColonTest, '')\n        .toLowerCase();\n    } catch (e) {\n      return null;\n    }\n    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n      return null;\n    }\n  }\n  if (base && !originIndependentUrl.test(href)) {\n    href = resolveUrl(base, href);\n  }\n  try {\n    href = encodeURI(href).replace(/%25/g, '%');\n  } catch (e) {\n    return null;\n  }\n  return href;\n}\n\nconst baseUrls = {};\nconst justDomain = /^[^:]+:\\/*[^/]*$/;\nconst protocol = /^([^:]+:)[\\s\\S]*$/;\nconst domain = /^([^:]+:\\/*[^/]*)[\\s\\S]*$/;\n\n/**\n * @param {string} base\n * @param {string} href\n */\nfunction resolveUrl(base, href) {\n  if (!baseUrls[' ' + base]) {\n    // we can ignore everything in base after the last slash of its path component,\n    // but we might need to add _that_\n    // https://tools.ietf.org/html/rfc3986#section-3\n    if (justDomain.test(base)) {\n      baseUrls[' ' + base] = base + '/';\n    } else {\n      baseUrls[' ' + base] = rtrim(base, '/', true);\n    }\n  }\n  base = baseUrls[' ' + base];\n  const relativeBase = base.indexOf(':') === -1;\n\n  if (href.substring(0, 2) === '//') {\n    if (relativeBase) {\n      return href;\n    }\n    return base.replace(protocol, '$1') + href;\n  } else if (href.charAt(0) === '/') {\n    if (relativeBase) {\n      return href;\n    }\n    return base.replace(domain, '$1') + href;\n  } else {\n    return base + href;\n  }\n}\n\nconst noopTest = { exec: function noopTest() {} };\n\nfunction merge(obj) {\n  let i = 1,\n    target,\n    key;\n\n  for (; i < arguments.length; i++) {\n    target = arguments[i];\n    for (key in target) {\n      if (Object.prototype.hasOwnProperty.call(target, key)) {\n        obj[key] = target[key];\n      }\n    }\n  }\n\n  return obj;\n}\n\nfunction splitCells(tableRow, count) {\n  // ensure that every cell-delimiting pipe has a space\n  // before it to distinguish it from an escaped pipe\n  const row = tableRow.replace(/\\|/g, (match, offset, str) => {\n      let escaped = false,\n        curr = offset;\n      while (--curr >= 0 && str[curr] === '\\\\') escaped = !escaped;\n      if (escaped) {\n        // odd number of slashes means | is escaped\n        // so we leave it alone\n        return '|';\n      } else {\n        // add space before unescaped |\n        return ' |';\n      }\n    }),\n    cells = row.split(/ \\|/);\n  let i = 0;\n\n  // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n  if (!cells[0].trim()) { cells.shift(); }\n  if (cells.length > 0 && !cells[cells.length - 1].trim()) { cells.pop(); }\n\n  if (cells.length > count) {\n    cells.splice(count);\n  } else {\n    while (cells.length < count) cells.push('');\n  }\n\n  for (; i < cells.length; i++) {\n    // leading or trailing whitespace is ignored per the gfm spec\n    cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n  }\n  return cells;\n}\n\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param {string} str\n * @param {string} c\n * @param {boolean} invert Remove suffix of non-c chars instead. Default falsey.\n */\nfunction rtrim(str, c, invert) {\n  const l = str.length;\n  if (l === 0) {\n    return '';\n  }\n\n  // Length of suffix matching the invert condition.\n  let suffLen = 0;\n\n  // Step left until we fail to match the invert condition.\n  while (suffLen < l) {\n    const currChar = str.charAt(l - suffLen - 1);\n    if (currChar === c && !invert) {\n      suffLen++;\n    } else if (currChar !== c && invert) {\n      suffLen++;\n    } else {\n      break;\n    }\n  }\n\n  return str.slice(0, l - suffLen);\n}\n\nfunction findClosingBracket(str, b) {\n  if (str.indexOf(b[1]) === -1) {\n    return -1;\n  }\n  const l = str.length;\n  let level = 0,\n    i = 0;\n  for (; i < l; i++) {\n    if (str[i] === '\\\\') {\n      i++;\n    } else if (str[i] === b[0]) {\n      level++;\n    } else if (str[i] === b[1]) {\n      level--;\n      if (level < 0) {\n        return i;\n      }\n    }\n  }\n  return -1;\n}\n\nfunction checkSanitizeDeprecation(opt) {\n  if (opt && opt.sanitize && !opt.silent) {\n    console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');\n  }\n}\n\n// copied from https://stackoverflow.com/a/5450113/806777\n/**\n * @param {string} pattern\n * @param {number} count\n */\nfunction repeatString(pattern, count) {\n  if (count < 1) {\n    return '';\n  }\n  let result = '';\n  while (count > 1) {\n    if (count & 1) {\n      result += pattern;\n    }\n    count >>= 1;\n    pattern += pattern;\n  }\n  return result + pattern;\n}\n\nfunction outputLink(cap, link, raw, lexer) {\n  const href = link.href;\n  const title = link.title ? escape(link.title) : null;\n  const text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n\n  if (cap[0].charAt(0) !== '!') {\n    lexer.state.inLink = true;\n    const token = {\n      type: 'link',\n      raw,\n      href,\n      title,\n      text,\n      tokens: lexer.inlineTokens(text, [])\n    };\n    lexer.state.inLink = false;\n    return token;\n  }\n  return {\n    type: 'image',\n    raw,\n    href,\n    title,\n    text: escape(text)\n  };\n}\n\nfunction indentCodeCompensation(raw, text) {\n  const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n\n  if (matchIndentToCode === null) {\n    return text;\n  }\n\n  const indentToCode = matchIndentToCode[1];\n\n  return text\n    .split('\\n')\n    .map(node => {\n      const matchIndentInNode = node.match(/^\\s+/);\n      if (matchIndentInNode === null) {\n        return node;\n      }\n\n      const [indentInNode] = matchIndentInNode;\n\n      if (indentInNode.length >= indentToCode.length) {\n        return node.slice(indentToCode.length);\n      }\n\n      return node;\n    })\n    .join('\\n');\n}\n\n/**\n * Tokenizer\n */\nclass Tokenizer {\n  constructor(options) {\n    this.options = options || defaults;\n  }\n\n  space(src) {\n    const cap = this.rules.block.newline.exec(src);\n    if (cap && cap[0].length > 0) {\n      return {\n        type: 'space',\n        raw: cap[0]\n      };\n    }\n  }\n\n  code(src) {\n    const cap = this.rules.block.code.exec(src);\n    if (cap) {\n      const text = cap[0].replace(/^ {1,4}/gm, '');\n      return {\n        type: 'code',\n        raw: cap[0],\n        codeBlockStyle: 'indented',\n        text: !this.options.pedantic\n          ? rtrim(text, '\\n')\n          : text\n      };\n    }\n  }\n\n  fences(src) {\n    const cap = this.rules.block.fences.exec(src);\n    if (cap) {\n      const raw = cap[0];\n      const text = indentCodeCompensation(raw, cap[3] || '');\n\n      return {\n        type: 'code',\n        raw,\n        lang: cap[2] ? cap[2].trim() : cap[2],\n        text\n      };\n    }\n  }\n\n  heading(src) {\n    const cap = this.rules.block.heading.exec(src);\n    if (cap) {\n      let text = cap[2].trim();\n\n      // remove trailing #s\n      if (/#$/.test(text)) {\n        const trimmed = rtrim(text, '#');\n        if (this.options.pedantic) {\n          text = trimmed.trim();\n        } else if (!trimmed || / $/.test(trimmed)) {\n          // CommonMark requires space before trailing #s\n          text = trimmed.trim();\n        }\n      }\n\n      const token = {\n        type: 'heading',\n        raw: cap[0],\n        depth: cap[1].length,\n        text,\n        tokens: []\n      };\n      this.lexer.inline(token.text, token.tokens);\n      return token;\n    }\n  }\n\n  hr(src) {\n    const cap = this.rules.block.hr.exec(src);\n    if (cap) {\n      return {\n        type: 'hr',\n        raw: cap[0]\n      };\n    }\n  }\n\n  blockquote(src) {\n    const cap = this.rules.block.blockquote.exec(src);\n    if (cap) {\n      const text = cap[0].replace(/^ *>[ \\t]?/gm, '');\n\n      return {\n        type: 'blockquote',\n        raw: cap[0],\n        tokens: this.lexer.blockTokens(text, []),\n        text\n      };\n    }\n  }\n\n  list(src) {\n    let cap = this.rules.block.list.exec(src);\n    if (cap) {\n      let raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine,\n        line, nextLine, rawLine, itemContents, endEarly;\n\n      let bull = cap[1].trim();\n      const isordered = bull.length > 1;\n\n      const list = {\n        type: 'list',\n        raw: '',\n        ordered: isordered,\n        start: isordered ? +bull.slice(0, -1) : '',\n        loose: false,\n        items: []\n      };\n\n      bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n\n      if (this.options.pedantic) {\n        bull = isordered ? bull : '[*+-]';\n      }\n\n      // Get next list item\n      const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);\n\n      // Check if current bullet point can start a new List Item\n      while (src) {\n        endEarly = false;\n        if (!(cap = itemRegex.exec(src))) {\n          break;\n        }\n\n        if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n          break;\n        }\n\n        raw = cap[0];\n        src = src.substring(raw.length);\n\n        line = cap[2].split('\\n', 1)[0];\n        nextLine = src.split('\\n', 1)[0];\n\n        if (this.options.pedantic) {\n          indent = 2;\n          itemContents = line.trimLeft();\n        } else {\n          indent = cap[2].search(/[^ ]/); // Find first non-space char\n          indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n          itemContents = line.slice(indent);\n          indent += cap[1].length;\n        }\n\n        blankLine = false;\n\n        if (!line && /^ *$/.test(nextLine)) { // Items begin with at most one blank line\n          raw += nextLine + '\\n';\n          src = src.substring(nextLine.length + 1);\n          endEarly = true;\n        }\n\n        if (!endEarly) {\n          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?: [^\\\\n]*)?(?:\\\\n|$))`);\n          const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n\n          // Check if following lines should be included in List Item\n          while (src) {\n            rawLine = src.split('\\n', 1)[0];\n            line = rawLine;\n\n            // Re-align to follow commonmark nesting rules\n            if (this.options.pedantic) {\n              line = line.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');\n            }\n\n            // End list item if found start of new bullet\n            if (nextBulletRegex.test(line)) {\n              break;\n            }\n\n            // Horizontal rule found\n            if (hrRegex.test(src)) {\n              break;\n            }\n\n            if (line.search(/[^ ]/) >= indent || !line.trim()) { // Dedent if possible\n              itemContents += '\\n' + line.slice(indent);\n            } else if (!blankLine) { // Until blank line, item doesn't need indentation\n              itemContents += '\\n' + line;\n            } else { // Otherwise, improper indentation ends this item\n              break;\n            }\n\n            if (!blankLine && !line.trim()) { // Check if current line is blank\n              blankLine = true;\n            }\n\n            raw += rawLine + '\\n';\n            src = src.substring(rawLine.length + 1);\n          }\n        }\n\n        if (!list.loose) {\n          // If the previous item ended with a blank line, the list is loose\n          if (endsWithBlankLine) {\n            list.loose = true;\n          } else if (/\\n *\\n *$/.test(raw)) {\n            endsWithBlankLine = true;\n          }\n        }\n\n        // Check for task list items\n        if (this.options.gfm) {\n          istask = /^\\[[ xX]\\] /.exec(itemContents);\n          if (istask) {\n            ischecked = istask[0] !== '[ ] ';\n            itemContents = itemContents.replace(/^\\[[ xX]\\] +/, '');\n          }\n        }\n\n        list.items.push({\n          type: 'list_item',\n          raw,\n          task: !!istask,\n          checked: ischecked,\n          loose: false,\n          text: itemContents\n        });\n\n        list.raw += raw;\n      }\n\n      // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n      list.items[list.items.length - 1].raw = raw.trimRight();\n      list.items[list.items.length - 1].text = itemContents.trimRight();\n      list.raw = list.raw.trimRight();\n\n      const l = list.items.length;\n\n      // Item child tokens handled here at end because we needed to have the final item to trim it first\n      for (i = 0; i < l; i++) {\n        this.lexer.state.top = false;\n        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n        const spacers = list.items[i].tokens.filter(t => t.type === 'space');\n        const hasMultipleLineBreaks = spacers.every(t => {\n          const chars = t.raw.split('');\n          let lineBreaks = 0;\n          for (const char of chars) {\n            if (char === '\\n') {\n              lineBreaks += 1;\n            }\n            if (lineBreaks > 1) {\n              return true;\n            }\n          }\n\n          return false;\n        });\n\n        if (!list.loose && spacers.length && hasMultipleLineBreaks) {\n          // Having a single line break doesn't mean a list is loose. A single line break is terminating the last list item\n          list.loose = true;\n          list.items[i].loose = true;\n        }\n      }\n\n      return list;\n    }\n  }\n\n  html(src) {\n    const cap = this.rules.block.html.exec(src);\n    if (cap) {\n      const token = {\n        type: 'html',\n        raw: cap[0],\n        pre: !this.options.sanitizer\n          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n        text: cap[0]\n      };\n      if (this.options.sanitize) {\n        token.type = 'paragraph';\n        token.text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);\n        token.tokens = [];\n        this.lexer.inline(token.text, token.tokens);\n      }\n      return token;\n    }\n  }\n\n  def(src) {\n    const cap = this.rules.block.def.exec(src);\n    if (cap) {\n      if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);\n      const tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n      return {\n        type: 'def',\n        tag,\n        raw: cap[0],\n        href: cap[2],\n        title: cap[3]\n      };\n    }\n  }\n\n  table(src) {\n    const cap = this.rules.block.table.exec(src);\n    if (cap) {\n      const item = {\n        type: 'table',\n        header: splitCells(cap[1]).map(c => { return { text: c }; }),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, '').split('\\n') : []\n      };\n\n      if (item.header.length === item.align.length) {\n        item.raw = cap[0];\n\n        let l = item.align.length;\n        let i, j, k, row;\n        for (i = 0; i < l; i++) {\n          if (/^ *-+: *$/.test(item.align[i])) {\n            item.align[i] = 'right';\n          } else if (/^ *:-+: *$/.test(item.align[i])) {\n            item.align[i] = 'center';\n          } else if (/^ *:-+ *$/.test(item.align[i])) {\n            item.align[i] = 'left';\n          } else {\n            item.align[i] = null;\n          }\n        }\n\n        l = item.rows.length;\n        for (i = 0; i < l; i++) {\n          item.rows[i] = splitCells(item.rows[i], item.header.length).map(c => { return { text: c }; });\n        }\n\n        // parse child tokens inside headers and cells\n\n        // header child tokens\n        l = item.header.length;\n        for (j = 0; j < l; j++) {\n          item.header[j].tokens = [];\n          this.lexer.inline(item.header[j].text, item.header[j].tokens);\n        }\n\n        // cell child tokens\n        l = item.rows.length;\n        for (j = 0; j < l; j++) {\n          row = item.rows[j];\n          for (k = 0; k < row.length; k++) {\n            row[k].tokens = [];\n            this.lexer.inline(row[k].text, row[k].tokens);\n          }\n        }\n\n        return item;\n      }\n    }\n  }\n\n  lheading(src) {\n    const cap = this.rules.block.lheading.exec(src);\n    if (cap) {\n      const token = {\n        type: 'heading',\n        raw: cap[0],\n        depth: cap[2].charAt(0) === '=' ? 1 : 2,\n        text: cap[1],\n        tokens: []\n      };\n      this.lexer.inline(token.text, token.tokens);\n      return token;\n    }\n  }\n\n  paragraph(src) {\n    const cap = this.rules.block.paragraph.exec(src);\n    if (cap) {\n      const token = {\n        type: 'paragraph',\n        raw: cap[0],\n        text: cap[1].charAt(cap[1].length - 1) === '\\n'\n          ? cap[1].slice(0, -1)\n          : cap[1],\n        tokens: []\n      };\n      this.lexer.inline(token.text, token.tokens);\n      return token;\n    }\n  }\n\n  text(src) {\n    const cap = this.rules.block.text.exec(src);\n    if (cap) {\n      const token = {\n        type: 'text',\n        raw: cap[0],\n        text: cap[0],\n        tokens: []\n      };\n      this.lexer.inline(token.text, token.tokens);\n      return token;\n    }\n  }\n\n  escape(src) {\n    const cap = this.rules.inline.escape.exec(src);\n    if (cap) {\n      return {\n        type: 'escape',\n        raw: cap[0],\n        text: escape(cap[1])\n      };\n    }\n  }\n\n  tag(src) {\n    const cap = this.rules.inline.tag.exec(src);\n    if (cap) {\n      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n        this.lexer.state.inLink = true;\n      } else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n        this.lexer.state.inLink = false;\n      }\n      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n        this.lexer.state.inRawBlock = true;\n      } else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n        this.lexer.state.inRawBlock = false;\n      }\n\n      return {\n        type: this.options.sanitize\n          ? 'text'\n          : 'html',\n        raw: cap[0],\n        inLink: this.lexer.state.inLink,\n        inRawBlock: this.lexer.state.inRawBlock,\n        text: this.options.sanitize\n          ? (this.options.sanitizer\n            ? this.options.sanitizer(cap[0])\n            : escape(cap[0]))\n          : cap[0]\n      };\n    }\n  }\n\n  link(src) {\n    const cap = this.rules.inline.link.exec(src);\n    if (cap) {\n      const trimmedUrl = cap[2].trim();\n      if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n        // commonmark requires matching angle brackets\n        if (!(/>$/.test(trimmedUrl))) {\n          return;\n        }\n\n        // ending angle bracket cannot be escaped\n        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n          return;\n        }\n      } else {\n        // find closing parenthesis\n        const lastParenIndex = findClosingBracket(cap[2], '()');\n        if (lastParenIndex > -1) {\n          const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n          const linkLen = start + cap[1].length + lastParenIndex;\n          cap[2] = cap[2].substring(0, lastParenIndex);\n          cap[0] = cap[0].substring(0, linkLen).trim();\n          cap[3] = '';\n        }\n      }\n      let href = cap[2];\n      let title = '';\n      if (this.options.pedantic) {\n        // split pedantic href and title\n        const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n\n        if (link) {\n          href = link[1];\n          title = link[3];\n        }\n      } else {\n        title = cap[3] ? cap[3].slice(1, -1) : '';\n      }\n\n      href = href.trim();\n      if (/^</.test(href)) {\n        if (this.options.pedantic && !(/>$/.test(trimmedUrl))) {\n          // pedantic allows starting angle bracket without ending angle bracket\n          href = href.slice(1);\n        } else {\n          href = href.slice(1, -1);\n        }\n      }\n      return outputLink(cap, {\n        href: href ? href.replace(this.rules.inline._escapes, '$1') : href,\n        title: title ? title.replace(this.rules.inline._escapes, '$1') : title\n      }, cap[0], this.lexer);\n    }\n  }\n\n  reflink(src, links) {\n    let cap;\n    if ((cap = this.rules.inline.reflink.exec(src))\n        || (cap = this.rules.inline.nolink.exec(src))) {\n      let link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n      link = links[link.toLowerCase()];\n      if (!link || !link.href) {\n        const text = cap[0].charAt(0);\n        return {\n          type: 'text',\n          raw: text,\n          text\n        };\n      }\n      return outputLink(cap, link, cap[0], this.lexer);\n    }\n  }\n\n  emStrong(src, maskedSrc, prevChar = '') {\n    let match = this.rules.inline.emStrong.lDelim.exec(src);\n    if (!match) return;\n\n    // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n    if (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u)) return;\n\n    const nextChar = match[1] || match[2] || '';\n\n    if (!nextChar || (nextChar && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar)))) {\n      const lLength = match[0].length - 1;\n      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n\n      const endReg = match[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;\n      endReg.lastIndex = 0;\n\n      // Clip maskedSrc to same section of string as src (move to lexer?)\n      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n\n      while ((match = endReg.exec(maskedSrc)) != null) {\n        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n\n        if (!rDelim) continue; // skip single * in __abc*abc__\n\n        rLength = rDelim.length;\n\n        if (match[3] || match[4]) { // found another Left Delim\n          delimTotal += rLength;\n          continue;\n        } else if (match[5] || match[6]) { // either Left or Right Delim\n          if (lLength % 3 && !((lLength + rLength) % 3)) {\n            midDelimTotal += rLength;\n            continue; // CommonMark Emphasis Rules 9-10\n          }\n        }\n\n        delimTotal -= rLength;\n\n        if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n\n        // Remove extra characters. *a*** -> *a*\n        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n\n        // Create `em` if smallest delimiter has odd char count. *a***\n        if (Math.min(lLength, rLength) % 2) {\n          const text = src.slice(1, lLength + match.index + rLength);\n          return {\n            type: 'em',\n            raw: src.slice(0, lLength + match.index + rLength + 1),\n            text,\n            tokens: this.lexer.inlineTokens(text, [])\n          };\n        }\n\n        // Create 'strong' if smallest delimiter has even char count. **a***\n        const text = src.slice(2, lLength + match.index + rLength - 1);\n        return {\n          type: 'strong',\n          raw: src.slice(0, lLength + match.index + rLength + 1),\n          text,\n          tokens: this.lexer.inlineTokens(text, [])\n        };\n      }\n    }\n  }\n\n  codespan(src) {\n    const cap = this.rules.inline.code.exec(src);\n    if (cap) {\n      let text = cap[2].replace(/\\n/g, ' ');\n      const hasNonSpaceChars = /[^ ]/.test(text);\n      const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n        text = text.substring(1, text.length - 1);\n      }\n      text = escape(text, true);\n      return {\n        type: 'codespan',\n        raw: cap[0],\n        text\n      };\n    }\n  }\n\n  br(src) {\n    const cap = this.rules.inline.br.exec(src);\n    if (cap) {\n      return {\n        type: 'br',\n        raw: cap[0]\n      };\n    }\n  }\n\n  del(src) {\n    const cap = this.rules.inline.del.exec(src);\n    if (cap) {\n      return {\n        type: 'del',\n        raw: cap[0],\n        text: cap[2],\n        tokens: this.lexer.inlineTokens(cap[2], [])\n      };\n    }\n  }\n\n  autolink(src, mangle) {\n    const cap = this.rules.inline.autolink.exec(src);\n    if (cap) {\n      let text, href;\n      if (cap[2] === '@') {\n        text = escape(this.options.mangle ? mangle(cap[1]) : cap[1]);\n        href = 'mailto:' + text;\n      } else {\n        text = escape(cap[1]);\n        href = text;\n      }\n\n      return {\n        type: 'link',\n        raw: cap[0],\n        text,\n        href,\n        tokens: [\n          {\n            type: 'text',\n            raw: text,\n            text\n          }\n        ]\n      };\n    }\n  }\n\n  url(src, mangle) {\n    let cap;\n    if (cap = this.rules.inline.url.exec(src)) {\n      let text, href;\n      if (cap[2] === '@') {\n        text = escape(this.options.mangle ? mangle(cap[0]) : cap[0]);\n        href = 'mailto:' + text;\n      } else {\n        // do extended autolink path validation\n        let prevCapZero;\n        do {\n          prevCapZero = cap[0];\n          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];\n        } while (prevCapZero !== cap[0]);\n        text = escape(cap[0]);\n        if (cap[1] === 'www.') {\n          href = 'http://' + text;\n        } else {\n          href = text;\n        }\n      }\n      return {\n        type: 'link',\n        raw: cap[0],\n        text,\n        href,\n        tokens: [\n          {\n            type: 'text',\n            raw: text,\n            text\n          }\n        ]\n      };\n    }\n  }\n\n  inlineText(src, smartypants) {\n    const cap = this.rules.inline.text.exec(src);\n    if (cap) {\n      let text;\n      if (this.lexer.state.inRawBlock) {\n        text = this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0];\n      } else {\n        text = escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);\n      }\n      return {\n        type: 'text',\n        raw: cap[0],\n        text\n      };\n    }\n  }\n}\n\n/**\n * Block-Level Grammar\n */\nconst block = {\n  newline: /^(?: *(?:\\n|$))+/,\n  code: /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/,\n  fences: /^ {0,3}(`{3,}(?=[^`\\n]*\\n)|~{3,})([^\\n]*)\\n(?:|([\\s\\S]*?)\\n)(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/,\n  hr: /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/,\n  heading: /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/,\n  blockquote: /^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/,\n  list: /^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/,\n  html: '^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (6)\n    + '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) open tag\n    + '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) closing tag\n    + ')',\n  def: /^ {0,3}\\[(label)\\]: *(?:\\n *)?<?([^\\s>]+)>?(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/,\n  table: noopTest,\n  lheading: /^([^\\n]+)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n  // regex template, placeholders will be replaced according to different paragraph\n  // interruption rules of commonmark and the original markdown spec:\n  _paragraph: /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/,\n  text: /^[^\\n]+/\n};\n\nblock._label = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nblock._title = /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/;\nblock.def = edit(block.def)\n  .replace('label', block._label)\n  .replace('title', block._title)\n  .getRegex();\n\nblock.bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nblock.listItemStart = edit(/^( *)(bull) */)\n  .replace('bull', block.bullet)\n  .getRegex();\n\nblock.list = edit(block.list)\n  .replace(/bull/g, block.bullet)\n  .replace('hr', '\\\\n+(?=\\\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$))')\n  .replace('def', '\\\\n+(?=' + block.def.source + ')')\n  .getRegex();\n\nblock._tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n  + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n  + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n  + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n  + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'\n  + '|track|ul';\nblock._comment = /<!--(?!-?>)[\\s\\S]*?(?:-->|$)/;\nblock.html = edit(block.html, 'i')\n  .replace('comment', block._comment)\n  .replace('tag', block._tag)\n  .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n  .getRegex();\n\nblock.paragraph = edit(block._paragraph)\n  .replace('hr', block.hr)\n  .replace('heading', ' {0,3}#{1,6} ')\n  .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n  .replace('|table', '')\n  .replace('blockquote', ' {0,3}>')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n  .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n\nblock.blockquote = edit(block.blockquote)\n  .replace('paragraph', block.paragraph)\n  .getRegex();\n\n/**\n * Normal Block Grammar\n */\n\nblock.normal = merge({}, block);\n\n/**\n * GFM Block Grammar\n */\n\nblock.gfm = merge({}, block.normal, {\n  table: '^ *([^\\\\n ].*\\\\|.*)\\\\n' // Header\n    + ' {0,3}(?:\\\\| *)?(:?-+:? *(?:\\\\| *:?-+:? *)*)(?:\\\\| *)?' // Align\n    + '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)' // Cells\n});\n\nblock.gfm.table = edit(block.gfm.table)\n  .replace('hr', block.hr)\n  .replace('heading', ' {0,3}#{1,6} ')\n  .replace('blockquote', ' {0,3}>')\n  .replace('code', ' {4}[^\\\\n]')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n  .replace('tag', block._tag) // tables can be interrupted by type (6) html blocks\n  .getRegex();\n\nblock.gfm.paragraph = edit(block._paragraph)\n  .replace('hr', block.hr)\n  .replace('heading', ' {0,3}#{1,6} ')\n  .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n  .replace('table', block.gfm.table) // interrupt paragraphs with table\n  .replace('blockquote', ' {0,3}>')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n  .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */\n\nblock.pedantic = merge({}, block.normal, {\n  html: edit(\n    '^ *(?:comment *(?:\\\\n|\\\\s*$)'\n    + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n    + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n    .replace('comment', block._comment)\n    .replace(/tag/g, '(?!(?:'\n      + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n      + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n      + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n    .getRegex(),\n  def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n  heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n  fences: noopTest, // fences not supported\n  paragraph: edit(block.normal._paragraph)\n    .replace('hr', block.hr)\n    .replace('heading', ' *#{1,6} *[^\\n]')\n    .replace('lheading', block.lheading)\n    .replace('blockquote', ' {0,3}>')\n    .replace('|fences', '')\n    .replace('|list', '')\n    .replace('|html', '')\n    .getRegex()\n});\n\n/**\n * Inline-Level Grammar\n */\nconst inline = {\n  escape: /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n  autolink: /^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/,\n  url: noopTest,\n  tag: '^comment'\n    + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>', // CDATA section\n  link: /^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/,\n  reflink: /^!?\\[(label)\\]\\[(ref)\\]/,\n  nolink: /^!?\\[(ref)\\](?:\\[\\])?/,\n  reflinkSearch: 'reflink|nolink(?!\\\\()',\n  emStrong: {\n    lDelim: /^(?:\\*+(?:([punct_])|[^\\s*]))|^_+(?:([punct*])|([^\\s_]))/,\n    //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.\n    //          () Skip orphan inside strong  () Consume to delim (1) #***                (2) a***#, a***                   (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a\n    rDelimAst: /^[^_*]*?\\_\\_[^_*]*?\\*[^_*]*?(?=\\_\\_)|[^*]+(?=[^*])|[punct_](\\*+)(?=[\\s]|$)|[^punct*_\\s](\\*+)(?=[punct_\\s]|$)|[punct_\\s](\\*+)(?=[^punct*_\\s])|[\\s](\\*+)(?=[punct_])|[punct_](\\*+)(?=[punct_])|[^punct*_\\s](\\*+)(?=[^punct*_\\s])/,\n    rDelimUnd: /^[^_*]*?\\*\\*[^_*]*?\\_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|[punct*](\\_+)(?=[\\s]|$)|[^punct*_\\s](\\_+)(?=[punct*\\s]|$)|[punct*\\s](\\_+)(?=[^punct*_\\s])|[\\s](\\_+)(?=[punct*])|[punct*](\\_+)(?=[punct*])/ // ^- Not allowed for _\n  },\n  code: /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/,\n  br: /^( {2,}|\\\\)\\n(?!\\s*$)/,\n  del: noopTest,\n  text: /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/,\n  punctuation: /^([\\spunctuation])/\n};\n\n// list of punctuation marks from CommonMark spec\n// without * and _ to handle the different emphasis markers * and _\ninline._punctuation = '!\"#$%&\\'()+\\\\-.,/:;<=>?@\\\\[\\\\]`^{|}~';\ninline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();\n\n// sequences em should skip over [title](link), `code`, <html>\ninline.blockSkip = /\\[[^\\]]*?\\]\\([^\\)]*?\\)|`[^`]*?`|<[^>]*?>/g;\ninline.escapedEmSt = /\\\\\\*|\\\\_/g;\n\ninline._comment = edit(block._comment).replace('(?:-->|$)', '-->').getRegex();\n\ninline.emStrong.lDelim = edit(inline.emStrong.lDelim)\n  .replace(/punct/g, inline._punctuation)\n  .getRegex();\n\ninline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, 'g')\n  .replace(/punct/g, inline._punctuation)\n  .getRegex();\n\ninline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, 'g')\n  .replace(/punct/g, inline._punctuation)\n  .getRegex();\n\ninline._escapes = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/g;\n\ninline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;\ninline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;\ninline.autolink = edit(inline.autolink)\n  .replace('scheme', inline._scheme)\n  .replace('email', inline._email)\n  .getRegex();\n\ninline._attribute = /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/;\n\ninline.tag = edit(inline.tag)\n  .replace('comment', inline._comment)\n  .replace('attribute', inline._attribute)\n  .getRegex();\n\ninline._label = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\ninline._href = /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/;\ninline._title = /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/;\n\ninline.link = edit(inline.link)\n  .replace('label', inline._label)\n  .replace('href', inline._href)\n  .replace('title', inline._title)\n  .getRegex();\n\ninline.reflink = edit(inline.reflink)\n  .replace('label', inline._label)\n  .replace('ref', block._label)\n  .getRegex();\n\ninline.nolink = edit(inline.nolink)\n  .replace('ref', block._label)\n  .getRegex();\n\ninline.reflinkSearch = edit(inline.reflinkSearch, 'g')\n  .replace('reflink', inline.reflink)\n  .replace('nolink', inline.nolink)\n  .getRegex();\n\n/**\n * Normal Inline Grammar\n */\n\ninline.normal = merge({}, inline);\n\n/**\n * Pedantic Inline Grammar\n */\n\ninline.pedantic = merge({}, inline.normal, {\n  strong: {\n    start: /^__|\\*\\*/,\n    middle: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n    endAst: /\\*\\*(?!\\*)/g,\n    endUnd: /__(?!_)/g\n  },\n  em: {\n    start: /^_|\\*/,\n    middle: /^()\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)|^_(?=\\S)([\\s\\S]*?\\S)_(?!_)/,\n    endAst: /\\*(?!\\*)/g,\n    endUnd: /_(?!_)/g\n  },\n  link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n    .replace('label', inline._label)\n    .getRegex(),\n  reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n    .replace('label', inline._label)\n    .getRegex()\n});\n\n/**\n * GFM Inline Grammar\n */\n\ninline.gfm = merge({}, inline.normal, {\n  escape: edit(inline.escape).replace('])', '~|])').getRegex(),\n  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,\n  url: /^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/,\n  _backpedal: /(?:[^?!.,:;*_~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,\n  del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n  text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n});\n\ninline.gfm.url = edit(inline.gfm.url, 'i')\n  .replace('email', inline.gfm._extended_email)\n  .getRegex();\n/**\n * GFM + Line Breaks Inline Grammar\n */\n\ninline.breaks = merge({}, inline.gfm, {\n  br: edit(inline.br).replace('{2,}', '*').getRegex(),\n  text: edit(inline.gfm.text)\n    .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n    .replace(/\\{2,\\}/g, '*')\n    .getRegex()\n});\n\n/**\n * smartypants text replacement\n * @param {string} text\n */\nfunction smartypants(text) {\n  return text\n    // em-dashes\n    .replace(/---/g, '\\u2014')\n    // en-dashes\n    .replace(/--/g, '\\u2013')\n    // opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, '$1\\u2018')\n    // closing singles & apostrophes\n    .replace(/'/g, '\\u2019')\n    // opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, '$1\\u201c')\n    // closing doubles\n    .replace(/\"/g, '\\u201d')\n    // ellipses\n    .replace(/\\.{3}/g, '\\u2026');\n}\n\n/**\n * mangle email addresses\n * @param {string} text\n */\nfunction mangle(text) {\n  let out = '',\n    i,\n    ch;\n\n  const l = text.length;\n  for (i = 0; i < l; i++) {\n    ch = text.charCodeAt(i);\n    if (Math.random() > 0.5) {\n      ch = 'x' + ch.toString(16);\n    }\n    out += '&#' + ch + ';';\n  }\n\n  return out;\n}\n\n/**\n * Block Lexer\n */\nclass Lexer {\n  constructor(options) {\n    this.tokens = [];\n    this.tokens.links = Object.create(null);\n    this.options = options || defaults;\n    this.options.tokenizer = this.options.tokenizer || new Tokenizer();\n    this.tokenizer = this.options.tokenizer;\n    this.tokenizer.options = this.options;\n    this.tokenizer.lexer = this;\n    this.inlineQueue = [];\n    this.state = {\n      inLink: false,\n      inRawBlock: false,\n      top: true\n    };\n\n    const rules = {\n      block: block.normal,\n      inline: inline.normal\n    };\n\n    if (this.options.pedantic) {\n      rules.block = block.pedantic;\n      rules.inline = inline.pedantic;\n    } else if (this.options.gfm) {\n      rules.block = block.gfm;\n      if (this.options.breaks) {\n        rules.inline = inline.breaks;\n      } else {\n        rules.inline = inline.gfm;\n      }\n    }\n    this.tokenizer.rules = rules;\n  }\n\n  /**\n   * Expose Rules\n   */\n  static get rules() {\n    return {\n      block,\n      inline\n    };\n  }\n\n  /**\n   * Static Lex Method\n   */\n  static lex(src, options) {\n    const lexer = new Lexer(options);\n    return lexer.lex(src);\n  }\n\n  /**\n   * Static Lex Inline Method\n   */\n  static lexInline(src, options) {\n    const lexer = new Lexer(options);\n    return lexer.inlineTokens(src);\n  }\n\n  /**\n   * Preprocessing\n   */\n  lex(src) {\n    src = src\n      .replace(/\\r\\n|\\r/g, '\\n');\n\n    this.blockTokens(src, this.tokens);\n\n    let next;\n    while (next = this.inlineQueue.shift()) {\n      this.inlineTokens(next.src, next.tokens);\n    }\n\n    return this.tokens;\n  }\n\n  /**\n   * Lexing\n   */\n  blockTokens(src, tokens = []) {\n    if (this.options.pedantic) {\n      src = src.replace(/\\t/g, '    ').replace(/^ +$/gm, '');\n    } else {\n      src = src.replace(/^( *)(\\t+)/gm, (_, leading, tabs) => {\n        return leading + '    '.repeat(tabs.length);\n      });\n    }\n\n    let token, lastToken, cutSrc, lastParagraphClipped;\n\n    while (src) {\n      if (this.options.extensions\n        && this.options.extensions.block\n        && this.options.extensions.block.some((extTokenizer) => {\n          if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            return true;\n          }\n          return false;\n        })) {\n        continue;\n      }\n\n      // newline\n      if (token = this.tokenizer.space(src)) {\n        src = src.substring(token.raw.length);\n        if (token.raw.length === 1 && tokens.length > 0) {\n          // if there's a single \\n as a spacer, it's terminating the last line,\n          // so move it there so that we don't get unecessary paragraph tags\n          tokens[tokens.length - 1].raw += '\\n';\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // code\n      if (token = this.tokenizer.code(src)) {\n        src = src.substring(token.raw.length);\n        lastToken = tokens[tokens.length - 1];\n        // An indented code block cannot interrupt a paragraph.\n        if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // fences\n      if (token = this.tokenizer.fences(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // heading\n      if (token = this.tokenizer.heading(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // hr\n      if (token = this.tokenizer.hr(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // blockquote\n      if (token = this.tokenizer.blockquote(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // list\n      if (token = this.tokenizer.list(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // html\n      if (token = this.tokenizer.html(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // def\n      if (token = this.tokenizer.def(src)) {\n        src = src.substring(token.raw.length);\n        lastToken = tokens[tokens.length - 1];\n        if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.raw;\n          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n        } else if (!this.tokens.links[token.tag]) {\n          this.tokens.links[token.tag] = {\n            href: token.href,\n            title: token.title\n          };\n        }\n        continue;\n      }\n\n      // table (gfm)\n      if (token = this.tokenizer.table(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // lheading\n      if (token = this.tokenizer.lheading(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // top-level paragraph\n      // prevent paragraph consuming extensions by clipping 'src' to extension start\n      cutSrc = src;\n      if (this.options.extensions && this.options.extensions.startBlock) {\n        let startIndex = Infinity;\n        const tempSrc = src.slice(1);\n        let tempStart;\n        this.options.extensions.startBlock.forEach(function(getStartIndex) {\n          tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n          if (typeof tempStart === 'number' && tempStart >= 0) { startIndex = Math.min(startIndex, tempStart); }\n        });\n        if (startIndex < Infinity && startIndex >= 0) {\n          cutSrc = src.substring(0, startIndex + 1);\n        }\n      }\n      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n        lastToken = tokens[tokens.length - 1];\n        if (lastParagraphClipped && lastToken.type === 'paragraph') {\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue.pop();\n          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        lastParagraphClipped = (cutSrc.length !== src.length);\n        src = src.substring(token.raw.length);\n        continue;\n      }\n\n      // text\n      if (token = this.tokenizer.text(src)) {\n        src = src.substring(token.raw.length);\n        lastToken = tokens[tokens.length - 1];\n        if (lastToken && lastToken.type === 'text') {\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue.pop();\n          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      if (src) {\n        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n        if (this.options.silent) {\n          console.error(errMsg);\n          break;\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n\n    this.state.top = true;\n    return tokens;\n  }\n\n  inline(src, tokens) {\n    this.inlineQueue.push({ src, tokens });\n  }\n\n  /**\n   * Lexing/Compiling\n   */\n  inlineTokens(src, tokens = []) {\n    let token, lastToken, cutSrc;\n\n    // String with links masked to avoid interference with em and strong\n    let maskedSrc = src;\n    let match;\n    let keepPrevChar, prevChar;\n\n    // Mask out reflinks\n    if (this.tokens.links) {\n      const links = Object.keys(this.tokens.links);\n      if (links.length > 0) {\n        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n          if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n          }\n        }\n      }\n    }\n    // Mask out other blocks\n    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n      maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n    }\n\n    // Mask out escaped em & strong delimiters\n    while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {\n      maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);\n    }\n\n    while (src) {\n      if (!keepPrevChar) {\n        prevChar = '';\n      }\n      keepPrevChar = false;\n\n      // extensions\n      if (this.options.extensions\n        && this.options.extensions.inline\n        && this.options.extensions.inline.some((extTokenizer) => {\n          if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            return true;\n          }\n          return false;\n        })) {\n        continue;\n      }\n\n      // escape\n      if (token = this.tokenizer.escape(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // tag\n      if (token = this.tokenizer.tag(src)) {\n        src = src.substring(token.raw.length);\n        lastToken = tokens[tokens.length - 1];\n        if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n          lastToken.raw += token.raw;\n          lastToken.text += token.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // link\n      if (token = this.tokenizer.link(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // reflink, nolink\n      if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n        src = src.substring(token.raw.length);\n        lastToken = tokens[tokens.length - 1];\n        if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n          lastToken.raw += token.raw;\n          lastToken.text += token.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // em & strong\n      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // code\n      if (token = this.tokenizer.codespan(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // br\n      if (token = this.tokenizer.br(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // del (gfm)\n      if (token = this.tokenizer.del(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // autolink\n      if (token = this.tokenizer.autolink(src, mangle)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // url (gfm)\n      if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // text\n      // prevent inlineText consuming extensions by clipping 'src' to extension start\n      cutSrc = src;\n      if (this.options.extensions && this.options.extensions.startInline) {\n        let startIndex = Infinity;\n        const tempSrc = src.slice(1);\n        let tempStart;\n        this.options.extensions.startInline.forEach(function(getStartIndex) {\n          tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n          if (typeof tempStart === 'number' && tempStart >= 0) { startIndex = Math.min(startIndex, tempStart); }\n        });\n        if (startIndex < Infinity && startIndex >= 0) {\n          cutSrc = src.substring(0, startIndex + 1);\n        }\n      }\n      if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {\n        src = src.substring(token.raw.length);\n        if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n          prevChar = token.raw.slice(-1);\n        }\n        keepPrevChar = true;\n        lastToken = tokens[tokens.length - 1];\n        if (lastToken && lastToken.type === 'text') {\n          lastToken.raw += token.raw;\n          lastToken.text += token.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      if (src) {\n        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n        if (this.options.silent) {\n          console.error(errMsg);\n          break;\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n\n    return tokens;\n  }\n}\n\n/**\n * Renderer\n */\nclass Renderer {\n  constructor(options) {\n    this.options = options || defaults;\n  }\n\n  code(code, infostring, escaped) {\n    const lang = (infostring || '').match(/\\S*/)[0];\n    if (this.options.highlight) {\n      const out = this.options.highlight(code, lang);\n      if (out != null && out !== code) {\n        escaped = true;\n        code = out;\n      }\n    }\n\n    code = code.replace(/\\n$/, '') + '\\n';\n\n    if (!lang) {\n      return '<pre><code>'\n        + (escaped ? code : escape(code, true))\n        + '</code></pre>\\n';\n    }\n\n    return '<pre><code class=\"'\n      + this.options.langPrefix\n      + escape(lang, true)\n      + '\">'\n      + (escaped ? code : escape(code, true))\n      + '</code></pre>\\n';\n  }\n\n  /**\n   * @param {string} quote\n   */\n  blockquote(quote) {\n    return `<blockquote>\\n${quote}</blockquote>\\n`;\n  }\n\n  html(html) {\n    return html;\n  }\n\n  /**\n   * @param {string} text\n   * @param {string} level\n   * @param {string} raw\n   * @param {any} slugger\n   */\n  heading(text, level, raw, slugger) {\n    if (this.options.headerIds) {\n      const id = this.options.headerPrefix + slugger.slug(raw);\n      return `<h${level} id=\"${id}\">${text}</h${level}>\\n`;\n    }\n\n    // ignore IDs\n    return `<h${level}>${text}</h${level}>\\n`;\n  }\n\n  hr() {\n    return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n  }\n\n  list(body, ordered, start) {\n    const type = ordered ? 'ol' : 'ul',\n      startatt = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n    return '<' + type + startatt + '>\\n' + body + '</' + type + '>\\n';\n  }\n\n  /**\n   * @param {string} text\n   */\n  listitem(text) {\n    return `<li>${text}</li>\\n`;\n  }\n\n  checkbox(checked) {\n    return '<input '\n      + (checked ? 'checked=\"\" ' : '')\n      + 'disabled=\"\" type=\"checkbox\"'\n      + (this.options.xhtml ? ' /' : '')\n      + '> ';\n  }\n\n  /**\n   * @param {string} text\n   */\n  paragraph(text) {\n    return `<p>${text}</p>\\n`;\n  }\n\n  /**\n   * @param {string} header\n   * @param {string} body\n   */\n  table(header, body) {\n    if (body) body = `<tbody>${body}</tbody>`;\n\n    return '<table>\\n'\n      + '<thead>\\n'\n      + header\n      + '</thead>\\n'\n      + body\n      + '</table>\\n';\n  }\n\n  /**\n   * @param {string} content\n   */\n  tablerow(content) {\n    return `<tr>\\n${content}</tr>\\n`;\n  }\n\n  tablecell(content, flags) {\n    const type = flags.header ? 'th' : 'td';\n    const tag = flags.align\n      ? `<${type} align=\"${flags.align}\">`\n      : `<${type}>`;\n    return tag + content + `</${type}>\\n`;\n  }\n\n  /**\n   * span level renderer\n   * @param {string} text\n   */\n  strong(text) {\n    return `<strong>${text}</strong>`;\n  }\n\n  /**\n   * @param {string} text\n   */\n  em(text) {\n    return `<em>${text}</em>`;\n  }\n\n  /**\n   * @param {string} text\n   */\n  codespan(text) {\n    return `<code>${text}</code>`;\n  }\n\n  br() {\n    return this.options.xhtml ? '<br/>' : '<br>';\n  }\n\n  /**\n   * @param {string} text\n   */\n  del(text) {\n    return `<del>${text}</del>`;\n  }\n\n  /**\n   * @param {string} href\n   * @param {string} title\n   * @param {string} text\n   */\n  link(href, title, text) {\n    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n    if (href === null) {\n      return text;\n    }\n    let out = '<a href=\"' + escape(href) + '\"';\n    if (title) {\n      out += ' title=\"' + title + '\"';\n    }\n    out += '>' + text + '</a>';\n    return out;\n  }\n\n  /**\n   * @param {string} href\n   * @param {string} title\n   * @param {string} text\n   */\n  image(href, title, text) {\n    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n    if (href === null) {\n      return text;\n    }\n\n    let out = `<img src=\"${href}\" alt=\"${text}\"`;\n    if (title) {\n      out += ` title=\"${title}\"`;\n    }\n    out += this.options.xhtml ? '/>' : '>';\n    return out;\n  }\n\n  text(text) {\n    return text;\n  }\n}\n\n/**\n * TextRenderer\n * returns only the textual part of the token\n */\nclass TextRenderer {\n  // no need for block level renderers\n  strong(text) {\n    return text;\n  }\n\n  em(text) {\n    return text;\n  }\n\n  codespan(text) {\n    return text;\n  }\n\n  del(text) {\n    return text;\n  }\n\n  html(text) {\n    return text;\n  }\n\n  text(text) {\n    return text;\n  }\n\n  link(href, title, text) {\n    return '' + text;\n  }\n\n  image(href, title, text) {\n    return '' + text;\n  }\n\n  br() {\n    return '';\n  }\n}\n\n/**\n * Slugger generates header id\n */\nclass Slugger {\n  constructor() {\n    this.seen = {};\n  }\n\n  /**\n   * @param {string} value\n   */\n  serialize(value) {\n    return value\n      .toLowerCase()\n      .trim()\n      // remove html tags\n      .replace(/<[!\\/a-z].*?>/ig, '')\n      // remove unwanted chars\n      .replace(/[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,./:;<=>?@[\\]^`{|}~]/g, '')\n      .replace(/\\s/g, '-');\n  }\n\n  /**\n   * Finds the next safe (unique) slug to use\n   * @param {string} originalSlug\n   * @param {boolean} isDryRun\n   */\n  getNextSafeSlug(originalSlug, isDryRun) {\n    let slug = originalSlug;\n    let occurenceAccumulator = 0;\n    if (this.seen.hasOwnProperty(slug)) {\n      occurenceAccumulator = this.seen[originalSlug];\n      do {\n        occurenceAccumulator++;\n        slug = originalSlug + '-' + occurenceAccumulator;\n      } while (this.seen.hasOwnProperty(slug));\n    }\n    if (!isDryRun) {\n      this.seen[originalSlug] = occurenceAccumulator;\n      this.seen[slug] = 0;\n    }\n    return slug;\n  }\n\n  /**\n   * Convert string to unique id\n   * @param {object} [options]\n   * @param {boolean} [options.dryrun] Generates the next unique slug without\n   * updating the internal accumulator.\n   */\n  slug(value, options = {}) {\n    const slug = this.serialize(value);\n    return this.getNextSafeSlug(slug, options.dryrun);\n  }\n}\n\n/**\n * Parsing & Compiling\n */\nclass Parser {\n  constructor(options) {\n    this.options = options || defaults;\n    this.options.renderer = this.options.renderer || new Renderer();\n    this.renderer = this.options.renderer;\n    this.renderer.options = this.options;\n    this.textRenderer = new TextRenderer();\n    this.slugger = new Slugger();\n  }\n\n  /**\n   * Static Parse Method\n   */\n  static parse(tokens, options) {\n    const parser = new Parser(options);\n    return parser.parse(tokens);\n  }\n\n  /**\n   * Static Parse Inline Method\n   */\n  static parseInline(tokens, options) {\n    const parser = new Parser(options);\n    return parser.parseInline(tokens);\n  }\n\n  /**\n   * Parse Loop\n   */\n  parse(tokens, top = true) {\n    let out = '',\n      i,\n      j,\n      k,\n      l2,\n      l3,\n      row,\n      cell,\n      header,\n      body,\n      token,\n      ordered,\n      start,\n      loose,\n      itemBody,\n      item,\n      checked,\n      task,\n      checkbox,\n      ret;\n\n    const l = tokens.length;\n    for (i = 0; i < l; i++) {\n      token = tokens[i];\n\n      // Run any renderer extensions\n      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);\n        if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(token.type)) {\n          out += ret || '';\n          continue;\n        }\n      }\n\n      switch (token.type) {\n        case 'space': {\n          continue;\n        }\n        case 'hr': {\n          out += this.renderer.hr();\n          continue;\n        }\n        case 'heading': {\n          out += this.renderer.heading(\n            this.parseInline(token.tokens),\n            token.depth,\n            unescape(this.parseInline(token.tokens, this.textRenderer)),\n            this.slugger);\n          continue;\n        }\n        case 'code': {\n          out += this.renderer.code(token.text,\n            token.lang,\n            token.escaped);\n          continue;\n        }\n        case 'table': {\n          header = '';\n\n          // header\n          cell = '';\n          l2 = token.header.length;\n          for (j = 0; j < l2; j++) {\n            cell += this.renderer.tablecell(\n              this.parseInline(token.header[j].tokens),\n              { header: true, align: token.align[j] }\n            );\n          }\n          header += this.renderer.tablerow(cell);\n\n          body = '';\n          l2 = token.rows.length;\n          for (j = 0; j < l2; j++) {\n            row = token.rows[j];\n\n            cell = '';\n            l3 = row.length;\n            for (k = 0; k < l3; k++) {\n              cell += this.renderer.tablecell(\n                this.parseInline(row[k].tokens),\n                { header: false, align: token.align[k] }\n              );\n            }\n\n            body += this.renderer.tablerow(cell);\n          }\n          out += this.renderer.table(header, body);\n          continue;\n        }\n        case 'blockquote': {\n          body = this.parse(token.tokens);\n          out += this.renderer.blockquote(body);\n          continue;\n        }\n        case 'list': {\n          ordered = token.ordered;\n          start = token.start;\n          loose = token.loose;\n          l2 = token.items.length;\n\n          body = '';\n          for (j = 0; j < l2; j++) {\n            item = token.items[j];\n            checked = item.checked;\n            task = item.task;\n\n            itemBody = '';\n            if (item.task) {\n              checkbox = this.renderer.checkbox(checked);\n              if (loose) {\n                if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {\n                  item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                    item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n                  }\n                } else {\n                  item.tokens.unshift({\n                    type: 'text',\n                    text: checkbox\n                  });\n                }\n              } else {\n                itemBody += checkbox;\n              }\n            }\n\n            itemBody += this.parse(item.tokens, loose);\n            body += this.renderer.listitem(itemBody, task, checked);\n          }\n\n          out += this.renderer.list(body, ordered, start);\n          continue;\n        }\n        case 'html': {\n          // TODO parse inline content if parameter markdown=1\n          out += this.renderer.html(token.text);\n          continue;\n        }\n        case 'paragraph': {\n          out += this.renderer.paragraph(this.parseInline(token.tokens));\n          continue;\n        }\n        case 'text': {\n          body = token.tokens ? this.parseInline(token.tokens) : token.text;\n          while (i + 1 < l && tokens[i + 1].type === 'text') {\n            token = tokens[++i];\n            body += '\\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);\n          }\n          out += top ? this.renderer.paragraph(body) : body;\n          continue;\n        }\n\n        default: {\n          const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n          if (this.options.silent) {\n            console.error(errMsg);\n            return;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Parse Inline Tokens\n   */\n  parseInline(tokens, renderer) {\n    renderer = renderer || this.renderer;\n    let out = '',\n      i,\n      token,\n      ret;\n\n    const l = tokens.length;\n    for (i = 0; i < l; i++) {\n      token = tokens[i];\n\n      // Run any renderer extensions\n      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);\n        if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {\n          out += ret || '';\n          continue;\n        }\n      }\n\n      switch (token.type) {\n        case 'escape': {\n          out += renderer.text(token.text);\n          break;\n        }\n        case 'html': {\n          out += renderer.html(token.text);\n          break;\n        }\n        case 'link': {\n          out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));\n          break;\n        }\n        case 'image': {\n          out += renderer.image(token.href, token.title, token.text);\n          break;\n        }\n        case 'strong': {\n          out += renderer.strong(this.parseInline(token.tokens, renderer));\n          break;\n        }\n        case 'em': {\n          out += renderer.em(this.parseInline(token.tokens, renderer));\n          break;\n        }\n        case 'codespan': {\n          out += renderer.codespan(token.text);\n          break;\n        }\n        case 'br': {\n          out += renderer.br();\n          break;\n        }\n        case 'del': {\n          out += renderer.del(this.parseInline(token.tokens, renderer));\n          break;\n        }\n        case 'text': {\n          out += renderer.text(token.text);\n          break;\n        }\n        default: {\n          const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n          if (this.options.silent) {\n            console.error(errMsg);\n            return;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n    }\n    return out;\n  }\n}\n\n/**\n * Marked\n */\nfunction marked(src, opt, callback) {\n  // throw error in case of non string input\n  if (typeof src === 'undefined' || src === null) {\n    throw new Error('marked(): input parameter is undefined or null');\n  }\n  if (typeof src !== 'string') {\n    throw new Error('marked(): input parameter is of type '\n      + Object.prototype.toString.call(src) + ', string expected');\n  }\n\n  if (typeof opt === 'function') {\n    callback = opt;\n    opt = null;\n  }\n\n  opt = merge({}, marked.defaults, opt || {});\n  checkSanitizeDeprecation(opt);\n\n  if (callback) {\n    const highlight = opt.highlight;\n    let tokens;\n\n    try {\n      tokens = Lexer.lex(src, opt);\n    } catch (e) {\n      return callback(e);\n    }\n\n    const done = function(err) {\n      let out;\n\n      if (!err) {\n        try {\n          if (opt.walkTokens) {\n            marked.walkTokens(tokens, opt.walkTokens);\n          }\n          out = Parser.parse(tokens, opt);\n        } catch (e) {\n          err = e;\n        }\n      }\n\n      opt.highlight = highlight;\n\n      return err\n        ? callback(err)\n        : callback(null, out);\n    };\n\n    if (!highlight || highlight.length < 3) {\n      return done();\n    }\n\n    delete opt.highlight;\n\n    if (!tokens.length) return done();\n\n    let pending = 0;\n    marked.walkTokens(tokens, function(token) {\n      if (token.type === 'code') {\n        pending++;\n        setTimeout(() => {\n          highlight(token.text, token.lang, function(err, code) {\n            if (err) {\n              return done(err);\n            }\n            if (code != null && code !== token.text) {\n              token.text = code;\n              token.escaped = true;\n            }\n\n            pending--;\n            if (pending === 0) {\n              done();\n            }\n          });\n        }, 0);\n      }\n    });\n\n    if (pending === 0) {\n      done();\n    }\n\n    return;\n  }\n\n  try {\n    const tokens = Lexer.lex(src, opt);\n    if (opt.walkTokens) {\n      marked.walkTokens(tokens, opt.walkTokens);\n    }\n    return Parser.parse(tokens, opt);\n  } catch (e) {\n    e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n    if (opt.silent) {\n      return '<p>An error occurred:</p><pre>'\n        + escape(e.message + '', true)\n        + '</pre>';\n    }\n    throw e;\n  }\n}\n\n/**\n * Options\n */\n\nmarked.options =\nmarked.setOptions = function(opt) {\n  merge(marked.defaults, opt);\n  changeDefaults(marked.defaults);\n  return marked;\n};\n\nmarked.getDefaults = getDefaults;\n\nmarked.defaults = defaults;\n\n/**\n * Use Extension\n */\n\nmarked.use = function(...args) {\n  const opts = merge({}, ...args);\n  const extensions = marked.defaults.extensions || { renderers: {}, childTokens: {} };\n  let hasExtensions;\n\n  args.forEach((pack) => {\n    // ==-- Parse \"addon\" extensions --== //\n    if (pack.extensions) {\n      hasExtensions = true;\n      pack.extensions.forEach((ext) => {\n        if (!ext.name) {\n          throw new Error('extension name required');\n        }\n        if (ext.renderer) { // Renderer extensions\n          const prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;\n          if (prevRenderer) {\n            // Replace extension with func to run new extension but fall back if false\n            extensions.renderers[ext.name] = function(...args) {\n              let ret = ext.renderer.apply(this, args);\n              if (ret === false) {\n                ret = prevRenderer.apply(this, args);\n              }\n              return ret;\n            };\n          } else {\n            extensions.renderers[ext.name] = ext.renderer;\n          }\n        }\n        if (ext.tokenizer) { // Tokenizer Extensions\n          if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n            throw new Error(\"extension level must be 'block' or 'inline'\");\n          }\n          if (extensions[ext.level]) {\n            extensions[ext.level].unshift(ext.tokenizer);\n          } else {\n            extensions[ext.level] = [ext.tokenizer];\n          }\n          if (ext.start) { // Function to check for start of token\n            if (ext.level === 'block') {\n              if (extensions.startBlock) {\n                extensions.startBlock.push(ext.start);\n              } else {\n                extensions.startBlock = [ext.start];\n              }\n            } else if (ext.level === 'inline') {\n              if (extensions.startInline) {\n                extensions.startInline.push(ext.start);\n              } else {\n                extensions.startInline = [ext.start];\n              }\n            }\n          }\n        }\n        if (ext.childTokens) { // Child tokens to be visited by walkTokens\n          extensions.childTokens[ext.name] = ext.childTokens;\n        }\n      });\n    }\n\n    // ==-- Parse \"overwrite\" extensions --== //\n    if (pack.renderer) {\n      const renderer = marked.defaults.renderer || new Renderer();\n      for (const prop in pack.renderer) {\n        const prevRenderer = renderer[prop];\n        // Replace renderer with func to run extension, but fall back if false\n        renderer[prop] = (...args) => {\n          let ret = pack.renderer[prop].apply(renderer, args);\n          if (ret === false) {\n            ret = prevRenderer.apply(renderer, args);\n          }\n          return ret;\n        };\n      }\n      opts.renderer = renderer;\n    }\n    if (pack.tokenizer) {\n      const tokenizer = marked.defaults.tokenizer || new Tokenizer();\n      for (const prop in pack.tokenizer) {\n        const prevTokenizer = tokenizer[prop];\n        // Replace tokenizer with func to run extension, but fall back if false\n        tokenizer[prop] = (...args) => {\n          let ret = pack.tokenizer[prop].apply(tokenizer, args);\n          if (ret === false) {\n            ret = prevTokenizer.apply(tokenizer, args);\n          }\n          return ret;\n        };\n      }\n      opts.tokenizer = tokenizer;\n    }\n\n    // ==-- Parse WalkTokens extensions --== //\n    if (pack.walkTokens) {\n      const walkTokens = marked.defaults.walkTokens;\n      opts.walkTokens = function(token) {\n        pack.walkTokens.call(this, token);\n        if (walkTokens) {\n          walkTokens.call(this, token);\n        }\n      };\n    }\n\n    if (hasExtensions) {\n      opts.extensions = extensions;\n    }\n\n    marked.setOptions(opts);\n  });\n};\n\n/**\n * Run callback for every token\n */\n\nmarked.walkTokens = function(tokens, callback) {\n  for (const token of tokens) {\n    callback.call(marked, token);\n    switch (token.type) {\n      case 'table': {\n        for (const cell of token.header) {\n          marked.walkTokens(cell.tokens, callback);\n        }\n        for (const row of token.rows) {\n          for (const cell of row) {\n            marked.walkTokens(cell.tokens, callback);\n          }\n        }\n        break;\n      }\n      case 'list': {\n        marked.walkTokens(token.items, callback);\n        break;\n      }\n      default: {\n        if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) { // Walk any extensions\n          marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {\n            marked.walkTokens(token[childTokens], callback);\n          });\n        } else if (token.tokens) {\n          marked.walkTokens(token.tokens, callback);\n        }\n      }\n    }\n  }\n};\n\n/**\n * Parse Inline\n * @param {string} src\n */\nmarked.parseInline = function(src, opt) {\n  // throw error in case of non string input\n  if (typeof src === 'undefined' || src === null) {\n    throw new Error('marked.parseInline(): input parameter is undefined or null');\n  }\n  if (typeof src !== 'string') {\n    throw new Error('marked.parseInline(): input parameter is of type '\n      + Object.prototype.toString.call(src) + ', string expected');\n  }\n\n  opt = merge({}, marked.defaults, opt || {});\n  checkSanitizeDeprecation(opt);\n\n  try {\n    const tokens = Lexer.lexInline(src, opt);\n    if (opt.walkTokens) {\n      marked.walkTokens(tokens, opt.walkTokens);\n    }\n    return Parser.parseInline(tokens, opt);\n  } catch (e) {\n    e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n    if (opt.silent) {\n      return '<p>An error occurred:</p><pre>'\n        + escape(e.message + '', true)\n        + '</pre>';\n    }\n    throw e;\n  }\n};\n\n/**\n * Expose\n */\nmarked.Parser = Parser;\nmarked.parser = Parser.parse;\nmarked.Renderer = Renderer;\nmarked.TextRenderer = TextRenderer;\nmarked.Lexer = Lexer;\nmarked.lexer = Lexer.lex;\nmarked.Tokenizer = Tokenizer;\nmarked.Slugger = Slugger;\nmarked.parse = marked;\n\nconst options = marked.options;\nconst setOptions = marked.setOptions;\nconst use = marked.use;\nconst walkTokens = marked.walkTokens;\nconst parseInline = marked.parseInline;\nconst parse = marked;\nconst parser = Parser.parse;\nconst lexer = Lexer.lex;\n\nexport { Lexer, Parser, Renderer, Slugger, TextRenderer, Tokenizer, defaults, getDefaults, lexer, marked, options, parse, parseInline, parser, setOptions, use, walkTokens };\n","<template>\n  <div style=\"text-align: left;\">\n    <div id=\"article\" v-html=\"markdownToHtml\"></div>\n  </div>\n</template>\n\n<script>\nimport { marked } from 'marked';\nimport { ARTICLES } from '@/constants.js';\n\nexport default {\n  name: 'ArticleView',\n  computed: {\n    markdownToHtml() {\n      const file = require(\"raw-loader!@/assets/articles/\" +\n        ARTICLES[this.$route.query.id][\"path\"]);\n      return marked(file['default']);\n    }\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n#article {\n  overflow-y: scroll;\n  height: 100%;\n}\n\n@media screen and (min-width: 1024px) {\n  #view {\n    margin-left: 25%; \n    margin-right: 25%;\n  }\n}\n\n@media screen and (min-width: 768px) and (max-width: 1023px){\n  #view {\n    margin-left: 10%; \n    margin-right: 10%;\n  }\n}\n\n@media screen and (max-width: 767px){\n  #view {\n    margin-left: 2%; \n    margin-right: 2%;\n  }\n}\n</style>","import mod from \"-!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./ArticleView.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./ArticleView.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./ArticleView.vue?vue&type=template&id=48680887&scoped=true\"\nimport script from \"./ArticleView.vue?vue&type=script&lang=js\"\nexport * from \"./ArticleView.vue?vue&type=script&lang=js\"\nimport style0 from \"./ArticleView.vue?vue&type=style&index=0&id=48680887&prod&lang=scss&scoped=true\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"48680887\",\n  null\n  \n)\n\nexport default component.exports","export default \"# Hello World\\n\\n\\n\\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce mollis ullamcorper ligula posuere consequat. Vivamus malesuada nisl eget lectus luctus, ac iaculis est viverra. Sed blandit dolor id orci euismod auctor. Vestibulum eget accumsan erat. Sed eget augue lorem. Morbi a turpis commodo, gravida nisl nec, facilisis diam. Proin vehicula lobortis ante. Praesent quis dolor vitae ante eleifend tempus. Donec tincidunt neque sed tellus dapibus rutrum. Nunc a ante ac ex efficitur ultrices. Sed scelerisque volutpat risus, at iaculis lacus.\\n\\nUt iaculis, velit vel facilisis tincidunt, lorem libero ultricies dolor, eget malesuada mauris tortor et magna. Pellentesque a metus at ex accumsan luctus. Vivamus id leo at quam volutpat fringilla. Morbi at metus ornare, placerat lacus eu, cursus leo. Ut in malesuada magna, id luctus eros. Proin facilisis ullamcorper massa in tincidunt. Morbi feugiat est eget libero dictum ultrices. Cras a aliquet lorem. Vivamus ac augue et lacus vulputate finibus quis eu leo. Maecenas hendrerit sit amet sem eu laoreet. Ut ut lectus efficitur, pharetra nulla in, fermentum massa. Quisque vestibulum rutrum turpis eu feugiat.\\n\\nProin vehicula blandit blandit. Vestibulum vel vehicula leo, ac sagittis nulla. Nullam non ante nunc. Mauris pulvinar varius gravida. Proin at erat malesuada, molestie lacus a, blandit tellus. Donec elementum vestibulum sapien, eu hendrerit risus egestas sed. Maecenas feugiat ornare lacus. Nunc congue velit purus, at pharetra dolor faucibus sed. Morbi mi arcu, facilisis euismod est at, gravida congue arcu. Phasellus eget orci urna. Nulla bibendum mollis ante nec ullamcorper. Morbi eu sodales massa, id sollicitudin purus. Curabitur maximus lorem a bibendum lobortis. Sed ut dui lectus. Proin viverra egestas sem vitae porta. Nunc ultricies malesuada maximus.\\n\\nSed id finibus diam. Phasellus pulvinar, risus id viverra ultrices, tellus est luctus tortor, sit amet consequat magna elit ac leo. Suspendisse gravida venenatis ipsum, at interdum risus. Maecenas aliquet quis lorem id varius. Donec ut dui in lectus volutpat blandit ac sit amet lacus. Nullam ac congue magna. Phasellus vitae luctus nunc, ut scelerisque eros.\\n\\nPhasellus sit amet purus justo. Maecenas auctor mattis eros in ullamcorper. Mauris at tellus tristique, convallis mauris a, maximus erat. Nunc non felis eu neque semper ornare. Etiam suscipit eget nisl id rhoncus. Curabitur cursus orci sit amet efficitur scelerisque. Nam non mi fermentum, pretium dui sit amet, cursus quam. Phasellus nibh nibh, pharetra non sollicitudin vitae, consectetur id elit. Donec hendrerit enim purus, eget sollicitudin nulla lobortis id. Morbi a diam hendrerit, pharetra felis sed, tempor ante. Sed volutpat est nec dui pellentesque mattis. Phasellus fringilla pretium tempor. Sed pretium consequat efficitur. Nullam efficitur a risus sed elementum. Fusce elementum fermentum convallis. Vestibulum sapien nulla, egestas id erat et, egestas accumsan mi.\\n\\nVivamus sed risus ac nunc sollicitudin auctor. Curabitur blandit tellus nisi, ut ornare purus fringilla quis. Maecenas eu tincidunt nunc. Ut a justo at dui finibus sagittis non quis risus. Aliquam condimentum risus sit amet mauris ornare, vitae porttitor dui congue. Etiam id rutrum ipsum. Fusce enim felis, venenatis nec condimentum id, commodo in ante. Pellentesque a magna tellus. \\n\\n## Hello World\\n\\n![Elmo](https://pbs.twimg.com/profile_images/1092947128370884613/LN-Wm4fc_400x400.jpg)\";","export const ARTICLES = {\n    \"helloworld\": {\n        \"name\": \"Hello World\",\n        \"image\": \"img/articles/code.jpg\",\n        \"description\": \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus in mollis lacus, quis efficitur lectus. Duis egestas felis a orci porttitor eleifend. Nunc ultrices felis risus, convallis rutrum dui ullamcorper vel. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Vestibulum a ultrices elit. Fusce porta magna fringilla felis molestie convallis. Nullam nec pretium neque. Nam purus risus, ultrices in augue a, gravida vestibulum nunc. Ut orci nisl, laoreet at mattis non, condimentum ut urna. Mauris at turpis a orci efficitur fringilla nec nec leo. Quisque rhoncus mauris ut erat cursus laoreet. Interdum et malesuada fames ac ante ipsum primis in faucibus. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Nullam a.\",\n        \"path\": \"helloworld.md\",\n    },\n    \"helloworl\": {\n        \"name\": \"Hello World\",\n        \"image\": \"img/articles/code.jpg\",\n        \"description\": \"Hello!\",\n        \"path\": \"helloworld.md\"\n    },\n    \"hellowor\": {\n        \"name\": \"Hello World\",\n        \"image\": \"img/articles/code.jpg\",\n        \"description\": \"Hello!\",\n        \"path\": \"helloworld.md\"\n    },\n    \"hellowo\": {\n        \"name\": \"Hello World\",\n        \"image\": \"img/articles/code.jpg\",\n        \"description\": \"Hello!\",\n        \"path\": \"helloworld.md\"\n    },\n    \"hellow\": {\n        \"name\": \"Hello World\",\n        \"image\": \"img/articles/code.jpg\",\n        \"description\": \"Hello!\",\n        \"path\": \"helloworld.md\"\n    },\n    \"hello\": {\n        \"name\": \"Hello World\",\n        \"image\": \"img/articles/code.jpg\",\n        \"description\": \"Hello!\",\n        \"path\": \"helloworld.md\"\n    },\n    \"hel\": {\n        \"name\": \"Hello World\",\n        \"image\": \"img/articles/code.jpg\",\n        \"description\": \"Hello!\",\n        \"path\": \"helloworld.md\"\n    },\n    \"hell\": {\n        \"name\": \"Hello World\",\n        \"image\": \"img/articles/code.jpg\",\n        \"description\": \"Hello!\",\n        \"path\": \"helloworld.md\"\n    }\n};\n\nexport const PUBLICATIONS = [\n    {\n        doi: \"http://dx.doi.org/10.1145/3551349.3556945\",\n        abstract: \"Infrastructure as Code (IaC) is the process of managing IT infrastructure via programmable configuration files (also called IaC scripts). Like other software artifacts, IaC scripts may contain security smells, which are coding patterns that can result in security weaknesses. Automated analysis tools to detect security smells in IaC scripts exist, but they focus on specific technologies such as Puppet, Ansible, or Chef. This means that when the detection of a new smell is implemented in one of the tools, it is not immediately available for the technologies supported by the other tools -- the only option is to duplicate the effort. This paper presents GLITCH, a new technology-agnostic framework that enables automated polyglot smell detection by transforming IaC scripts into an intermediate representation, on which different security smell detectors can be defined. GLITCH currently supports the detection of nine different security smells in scripts written in Puppet, Ansible, or Chef. We compare GLITCH with state-of-the-art security smell detectors. The results obtained not only show that GLITCH can reduce the effort of writing security smell analyses for multiple IaC technologies, but also that it has higher precision and recall than the current state-of-the-art tools.\",\n        pdf: \"https://arxiv.org/pdf/2205.14371.pdf\",\n        badges: [\n            {\n                name: \"Artifact Evaluation Award (Reusable)\",\n                link: \"https://www.acm.org/publications/policies/artifact-review-and-badging-current#reusable\"\n            },\n            {\n                name: \"Dataset\",\n                link: \"https://figshare.com/articles/dataset/GLITCH_Replication_Package_with_Code_and_Datasets_ASE_2022_/19726603/2\"\n            }\n        ]\n    }\n];","var map = {\n\t\"./helloworld.md\": 363\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 1167;"],"names":["render","_vm","this","_h","$createElement","_c","_self","staticStyle","attrs","domProps","_s","markdownToHtml","staticRenderFns","getDefaults","baseUrl","breaks","extensions","gfm","headerIds","headerPrefix","highlight","langPrefix","mangle","pedantic","renderer","sanitize","sanitizer","silent","smartLists","smartypants","tokenizer","walkTokens","xhtml","defaults","changeDefaults","newDefaults","escapeTest","escapeReplace","escapeTestNoEncode","escapeReplaceNoEncode","escapeReplacements","getEscapeReplacement","ch","escape","html","encode","test","replace","unescapeTest","unescape","_","n","toLowerCase","charAt","String","fromCharCode","parseInt","substring","caret","edit","regex","opt","source","obj","name","val","getRegex","RegExp","nonWordAndColonTest","originIndependentUrl","cleanUrl","base","href","prot","decodeURIComponent","e","indexOf","resolveUrl","encodeURI","baseUrls","justDomain","protocol","domain","rtrim","relativeBase","noopTest","exec","merge","target","key","i","arguments","length","Object","prototype","hasOwnProperty","call","splitCells","tableRow","count","row","match","offset","str","escaped","curr","cells","split","trim","shift","pop","splice","push","c","invert","l","suffLen","currChar","slice","findClosingBracket","b","level","checkSanitizeDeprecation","console","warn","repeatString","pattern","result","outputLink","cap","link","raw","lexer","title","text","state","inLink","token","type","tokens","inlineTokens","indentCodeCompensation","matchIndentToCode","indentToCode","map","node","matchIndentInNode","indentInNode","join","Tokenizer","constructor","options","space","src","rules","block","newline","code","codeBlockStyle","fences","lang","heading","trimmed","depth","inline","hr","blockquote","blockTokens","list","istask","ischecked","indent","blankLine","endsWithBlankLine","line","nextLine","rawLine","itemContents","endEarly","bull","isordered","ordered","start","loose","items","itemRegex","trimLeft","search","nextBulletRegex","Math","min","hrRegex","task","checked","trimRight","top","spacers","filter","t","hasMultipleLineBreaks","every","chars","lineBreaks","char","pre","def","tag","table","item","header","align","rows","j","k","lheading","paragraph","inRawBlock","trimmedUrl","rtrimSlash","lastParenIndex","linkLen","_escapes","reflink","links","nolink","emStrong","maskedSrc","prevChar","lDelim","nextChar","punctuation","lLength","rDelim","rLength","delimTotal","midDelimTotal","endReg","rDelimAst","rDelimUnd","lastIndex","index","codespan","hasNonSpaceChars","hasSpaceCharsOnBothEnds","br","del","autolink","url","prevCapZero","_backpedal","inlineText","_paragraph","_label","_title","bullet","listItemStart","_tag","_comment","normal","reflinkSearch","out","charCodeAt","random","toString","_punctuation","blockSkip","escapedEmSt","_scheme","_email","_attribute","_href","strong","middle","endAst","endUnd","em","_extended_email","Lexer","create","inlineQueue","static","lex","next","lastToken","cutSrc","lastParagraphClipped","leading","tabs","repeat","some","extTokenizer","startBlock","startIndex","Infinity","tempSrc","tempStart","forEach","getStartIndex","errMsg","error","Error","keepPrevChar","keys","includes","lastIndexOf","startInline","Renderer","infostring","quote","slugger","id","slug","body","startatt","listitem","checkbox","tablerow","content","tablecell","flags","image","TextRenderer","Slugger","seen","serialize","value","getNextSafeSlug","originalSlug","isDryRun","occurenceAccumulator","dryrun","Parser","textRenderer","parser","parse","parseInline","l2","l3","cell","itemBody","ret","renderers","unshift","marked","callback","done","err","pending","setTimeout","message","setOptions","use","args","opts","childTokens","hasExtensions","pack","ext","prevRenderer","apply","prop","prevTokenizer","lexInline","computed","ARTICLES","component","PUBLICATIONS","doi","abstract","pdf","badges","webpackContext","req","webpackContextResolve","__webpack_require__","o","resolve","module","exports"],"sourceRoot":""}