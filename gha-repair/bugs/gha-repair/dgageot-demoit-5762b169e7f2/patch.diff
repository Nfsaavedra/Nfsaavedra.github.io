diff --git a/.github/workflows/go.yml b/.github/workflows/go.yml
index c4dbab1..2f7ac00 100644
--- a/.github/workflows/go.yml
+++ b/.github/workflows/go.yml
@@ -1,11 +1,11 @@
 name: Go
-on: [push]
+on: push
 jobs:
   build:
     runs-on: ubuntu-latest
     steps:
-    - uses: actions/checkout@v2
     - uses: actions/setup-go@v2
       with:
-        go-version: '1.14'
+        go-version: 1.14
+    - uses: actions/checkout@v2
     - run: go build
diff --git a/vendor/github.com/chromedp/cdproto/target/easyjson.go b/vendor/github.com/chromedp/cdproto/target/easyjson.go
new file mode 100644
index 0000000..a374259
--- /dev/null
+++ b/vendor/github.com/chromedp/cdproto/target/easyjson.go
@@ -0,0 +1,2436 @@
+// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.
+
+package target
+
+import (
+	json "encoding/json"
+	cdp "github.com/chromedp/cdproto/cdp"
+	easyjson "github.com/mailru/easyjson"
+	jlexer "github.com/mailru/easyjson/jlexer"
+	jwriter "github.com/mailru/easyjson/jwriter"
+)
+
+// suppress unused package warning
+var (
+	_ *json.RawMessage
+	_ *jlexer.Lexer
+	_ *jwriter.Writer
+	_ easyjson.Marshaler
+)
+
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget(in *jlexer.Lexer, out *SetRemoteLocationsParams) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "locations":
+			if in.IsNull() {
+				in.Skip()
+				out.Locations = nil
+			} else {
+				in.Delim('[')
+				if out.Locations == nil {
+					if !in.IsDelim(']') {
+						out.Locations = make([]*RemoteLocation, 0, 8)
+					} else {
+						out.Locations = []*RemoteLocation{}
+					}
+				} else {
+					out.Locations = (out.Locations)[:0]
+				}
+				for !in.IsDelim(']') {
+					var v1 *RemoteLocation
+					if in.IsNull() {
+						in.Skip()
+						v1 = nil
+					} else {
+						if v1 == nil {
+							v1 = new(RemoteLocation)
+						}
+						(*v1).UnmarshalEasyJSON(in)
+					}
+					out.Locations = append(out.Locations, v1)
+					in.WantComma()
+				}
+				in.Delim(']')
+			}
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget(out *jwriter.Writer, in SetRemoteLocationsParams) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	{
+		const prefix string = ",\"locations\":"
+		out.RawString(prefix[1:])
+		if in.Locations == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
+			out.RawString("null")
+		} else {
+			out.RawByte('[')
+			for v2, v3 := range in.Locations {
+				if v2 > 0 {
+					out.RawByte(',')
+				}
+				if v3 == nil {
+					out.RawString("null")
+				} else {
+					(*v3).MarshalEasyJSON(out)
+				}
+			}
+			out.RawByte(']')
+		}
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v SetRemoteLocationsParams) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v SetRemoteLocationsParams) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *SetRemoteLocationsParams) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *SetRemoteLocationsParams) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget1(in *jlexer.Lexer, out *SetDiscoverTargetsParams) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "discover":
+			out.Discover = bool(in.Bool())
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget1(out *jwriter.Writer, in SetDiscoverTargetsParams) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	{
+		const prefix string = ",\"discover\":"
+		out.RawString(prefix[1:])
+		out.Bool(bool(in.Discover))
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v SetDiscoverTargetsParams) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget1(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v SetDiscoverTargetsParams) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget1(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *SetDiscoverTargetsParams) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget1(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *SetDiscoverTargetsParams) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget1(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget2(in *jlexer.Lexer, out *SetAutoAttachParams) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "autoAttach":
+			out.AutoAttach = bool(in.Bool())
+		case "waitForDebuggerOnStart":
+			out.WaitForDebuggerOnStart = bool(in.Bool())
+		case "flatten":
+			out.Flatten = bool(in.Bool())
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget2(out *jwriter.Writer, in SetAutoAttachParams) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	{
+		const prefix string = ",\"autoAttach\":"
+		out.RawString(prefix[1:])
+		out.Bool(bool(in.AutoAttach))
+	}
+	{
+		const prefix string = ",\"waitForDebuggerOnStart\":"
+		out.RawString(prefix)
+		out.Bool(bool(in.WaitForDebuggerOnStart))
+	}
+	if in.Flatten {
+		const prefix string = ",\"flatten\":"
+		out.RawString(prefix)
+		out.Bool(bool(in.Flatten))
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v SetAutoAttachParams) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget2(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v SetAutoAttachParams) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget2(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *SetAutoAttachParams) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget2(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *SetAutoAttachParams) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget2(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget3(in *jlexer.Lexer, out *RemoteLocation) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "host":
+			out.Host = string(in.String())
+		case "port":
+			out.Port = int64(in.Int64())
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget3(out *jwriter.Writer, in RemoteLocation) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	{
+		const prefix string = ",\"host\":"
+		out.RawString(prefix[1:])
+		out.String(string(in.Host))
+	}
+	{
+		const prefix string = ",\"port\":"
+		out.RawString(prefix)
+		out.Int64(int64(in.Port))
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v RemoteLocation) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget3(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v RemoteLocation) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget3(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *RemoteLocation) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget3(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *RemoteLocation) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget3(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget4(in *jlexer.Lexer, out *Info) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "targetId":
+			out.TargetID = ID(in.String())
+		case "type":
+			out.Type = string(in.String())
+		case "title":
+			out.Title = string(in.String())
+		case "url":
+			out.URL = string(in.String())
+		case "attached":
+			out.Attached = bool(in.Bool())
+		case "openerId":
+			out.OpenerID = ID(in.String())
+		case "browserContextId":
+			out.BrowserContextID = cdp.BrowserContextID(in.String())
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget4(out *jwriter.Writer, in Info) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	{
+		const prefix string = ",\"targetId\":"
+		out.RawString(prefix[1:])
+		out.String(string(in.TargetID))
+	}
+	{
+		const prefix string = ",\"type\":"
+		out.RawString(prefix)
+		out.String(string(in.Type))
+	}
+	{
+		const prefix string = ",\"title\":"
+		out.RawString(prefix)
+		out.String(string(in.Title))
+	}
+	{
+		const prefix string = ",\"url\":"
+		out.RawString(prefix)
+		out.String(string(in.URL))
+	}
+	{
+		const prefix string = ",\"attached\":"
+		out.RawString(prefix)
+		out.Bool(bool(in.Attached))
+	}
+	if in.OpenerID != "" {
+		const prefix string = ",\"openerId\":"
+		out.RawString(prefix)
+		out.String(string(in.OpenerID))
+	}
+	if in.BrowserContextID != "" {
+		const prefix string = ",\"browserContextId\":"
+		out.RawString(prefix)
+		out.String(string(in.BrowserContextID))
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v Info) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget4(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v Info) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget4(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *Info) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget4(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *Info) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget4(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget5(in *jlexer.Lexer, out *GetTargetsReturns) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "targetInfos":
+			if in.IsNull() {
+				in.Skip()
+				out.TargetInfos = nil
+			} else {
+				in.Delim('[')
+				if out.TargetInfos == nil {
+					if !in.IsDelim(']') {
+						out.TargetInfos = make([]*Info, 0, 8)
+					} else {
+						out.TargetInfos = []*Info{}
+					}
+				} else {
+					out.TargetInfos = (out.TargetInfos)[:0]
+				}
+				for !in.IsDelim(']') {
+					var v4 *Info
+					if in.IsNull() {
+						in.Skip()
+						v4 = nil
+					} else {
+						if v4 == nil {
+							v4 = new(Info)
+						}
+						(*v4).UnmarshalEasyJSON(in)
+					}
+					out.TargetInfos = append(out.TargetInfos, v4)
+					in.WantComma()
+				}
+				in.Delim(']')
+			}
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget5(out *jwriter.Writer, in GetTargetsReturns) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	if len(in.TargetInfos) != 0 {
+		const prefix string = ",\"targetInfos\":"
+		first = false
+		out.RawString(prefix[1:])
+		{
+			out.RawByte('[')
+			for v5, v6 := range in.TargetInfos {
+				if v5 > 0 {
+					out.RawByte(',')
+				}
+				if v6 == nil {
+					out.RawString("null")
+				} else {
+					(*v6).MarshalEasyJSON(out)
+				}
+			}
+			out.RawByte(']')
+		}
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v GetTargetsReturns) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget5(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v GetTargetsReturns) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget5(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *GetTargetsReturns) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget5(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *GetTargetsReturns) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget5(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget6(in *jlexer.Lexer, out *GetTargetsParams) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget6(out *jwriter.Writer, in GetTargetsParams) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v GetTargetsParams) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget6(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v GetTargetsParams) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget6(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *GetTargetsParams) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget6(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *GetTargetsParams) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget6(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget7(in *jlexer.Lexer, out *GetTargetInfoReturns) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "targetInfo":
+			if in.IsNull() {
+				in.Skip()
+				out.TargetInfo = nil
+			} else {
+				if out.TargetInfo == nil {
+					out.TargetInfo = new(Info)
+				}
+				(*out.TargetInfo).UnmarshalEasyJSON(in)
+			}
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget7(out *jwriter.Writer, in GetTargetInfoReturns) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	if in.TargetInfo != nil {
+		const prefix string = ",\"targetInfo\":"
+		first = false
+		out.RawString(prefix[1:])
+		(*in.TargetInfo).MarshalEasyJSON(out)
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v GetTargetInfoReturns) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget7(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v GetTargetInfoReturns) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget7(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *GetTargetInfoReturns) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget7(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *GetTargetInfoReturns) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget7(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget8(in *jlexer.Lexer, out *GetTargetInfoParams) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "targetId":
+			out.TargetID = ID(in.String())
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget8(out *jwriter.Writer, in GetTargetInfoParams) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	if in.TargetID != "" {
+		const prefix string = ",\"targetId\":"
+		first = false
+		out.RawString(prefix[1:])
+		out.String(string(in.TargetID))
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v GetTargetInfoParams) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget8(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v GetTargetInfoParams) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget8(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *GetTargetInfoParams) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget8(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *GetTargetInfoParams) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget8(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget9(in *jlexer.Lexer, out *GetBrowserContextsReturns) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "browserContextIds":
+			if in.IsNull() {
+				in.Skip()
+				out.BrowserContextIds = nil
+			} else {
+				in.Delim('[')
+				if out.BrowserContextIds == nil {
+					if !in.IsDelim(']') {
+						out.BrowserContextIds = make([]cdp.BrowserContextID, 0, 4)
+					} else {
+						out.BrowserContextIds = []cdp.BrowserContextID{}
+					}
+				} else {
+					out.BrowserContextIds = (out.BrowserContextIds)[:0]
+				}
+				for !in.IsDelim(']') {
+					var v7 cdp.BrowserContextID
+					v7 = cdp.BrowserContextID(in.String())
+					out.BrowserContextIds = append(out.BrowserContextIds, v7)
+					in.WantComma()
+				}
+				in.Delim(']')
+			}
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget9(out *jwriter.Writer, in GetBrowserContextsReturns) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	if len(in.BrowserContextIds) != 0 {
+		const prefix string = ",\"browserContextIds\":"
+		first = false
+		out.RawString(prefix[1:])
+		{
+			out.RawByte('[')
+			for v8, v9 := range in.BrowserContextIds {
+				if v8 > 0 {
+					out.RawByte(',')
+				}
+				out.String(string(v9))
+			}
+			out.RawByte(']')
+		}
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v GetBrowserContextsReturns) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget9(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v GetBrowserContextsReturns) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget9(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *GetBrowserContextsReturns) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget9(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *GetBrowserContextsReturns) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget9(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget10(in *jlexer.Lexer, out *GetBrowserContextsParams) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget10(out *jwriter.Writer, in GetBrowserContextsParams) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v GetBrowserContextsParams) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget10(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v GetBrowserContextsParams) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget10(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *GetBrowserContextsParams) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget10(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *GetBrowserContextsParams) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget10(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget11(in *jlexer.Lexer, out *ExposeDevToolsProtocolParams) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "targetId":
+			out.TargetID = ID(in.String())
+		case "bindingName":
+			out.BindingName = string(in.String())
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget11(out *jwriter.Writer, in ExposeDevToolsProtocolParams) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	{
+		const prefix string = ",\"targetId\":"
+		out.RawString(prefix[1:])
+		out.String(string(in.TargetID))
+	}
+	if in.BindingName != "" {
+		const prefix string = ",\"bindingName\":"
+		out.RawString(prefix)
+		out.String(string(in.BindingName))
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v ExposeDevToolsProtocolParams) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget11(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v ExposeDevToolsProtocolParams) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget11(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *ExposeDevToolsProtocolParams) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget11(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *ExposeDevToolsProtocolParams) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget11(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget12(in *jlexer.Lexer, out *EventTargetInfoChanged) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "targetInfo":
+			if in.IsNull() {
+				in.Skip()
+				out.TargetInfo = nil
+			} else {
+				if out.TargetInfo == nil {
+					out.TargetInfo = new(Info)
+				}
+				(*out.TargetInfo).UnmarshalEasyJSON(in)
+			}
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget12(out *jwriter.Writer, in EventTargetInfoChanged) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	{
+		const prefix string = ",\"targetInfo\":"
+		out.RawString(prefix[1:])
+		if in.TargetInfo == nil {
+			out.RawString("null")
+		} else {
+			(*in.TargetInfo).MarshalEasyJSON(out)
+		}
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v EventTargetInfoChanged) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget12(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v EventTargetInfoChanged) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget12(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *EventTargetInfoChanged) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget12(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *EventTargetInfoChanged) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget12(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget13(in *jlexer.Lexer, out *EventTargetDestroyed) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "targetId":
+			out.TargetID = ID(in.String())
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget13(out *jwriter.Writer, in EventTargetDestroyed) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	{
+		const prefix string = ",\"targetId\":"
+		out.RawString(prefix[1:])
+		out.String(string(in.TargetID))
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v EventTargetDestroyed) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget13(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v EventTargetDestroyed) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget13(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *EventTargetDestroyed) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget13(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *EventTargetDestroyed) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget13(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget14(in *jlexer.Lexer, out *EventTargetCreated) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "targetInfo":
+			if in.IsNull() {
+				in.Skip()
+				out.TargetInfo = nil
+			} else {
+				if out.TargetInfo == nil {
+					out.TargetInfo = new(Info)
+				}
+				(*out.TargetInfo).UnmarshalEasyJSON(in)
+			}
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget14(out *jwriter.Writer, in EventTargetCreated) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	{
+		const prefix string = ",\"targetInfo\":"
+		out.RawString(prefix[1:])
+		if in.TargetInfo == nil {
+			out.RawString("null")
+		} else {
+			(*in.TargetInfo).MarshalEasyJSON(out)
+		}
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v EventTargetCreated) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget14(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v EventTargetCreated) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget14(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *EventTargetCreated) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget14(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *EventTargetCreated) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget14(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget15(in *jlexer.Lexer, out *EventTargetCrashed) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "targetId":
+			out.TargetID = ID(in.String())
+		case "status":
+			out.Status = string(in.String())
+		case "errorCode":
+			out.ErrorCode = int64(in.Int64())
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget15(out *jwriter.Writer, in EventTargetCrashed) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	{
+		const prefix string = ",\"targetId\":"
+		out.RawString(prefix[1:])
+		out.String(string(in.TargetID))
+	}
+	{
+		const prefix string = ",\"status\":"
+		out.RawString(prefix)
+		out.String(string(in.Status))
+	}
+	{
+		const prefix string = ",\"errorCode\":"
+		out.RawString(prefix)
+		out.Int64(int64(in.ErrorCode))
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v EventTargetCrashed) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget15(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v EventTargetCrashed) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget15(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *EventTargetCrashed) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget15(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *EventTargetCrashed) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget15(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget16(in *jlexer.Lexer, out *EventReceivedMessageFromTarget) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "sessionId":
+			out.SessionID = SessionID(in.String())
+		case "message":
+			out.Message = string(in.String())
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget16(out *jwriter.Writer, in EventReceivedMessageFromTarget) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	{
+		const prefix string = ",\"sessionId\":"
+		out.RawString(prefix[1:])
+		out.String(string(in.SessionID))
+	}
+	{
+		const prefix string = ",\"message\":"
+		out.RawString(prefix)
+		out.String(string(in.Message))
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v EventReceivedMessageFromTarget) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget16(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v EventReceivedMessageFromTarget) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget16(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *EventReceivedMessageFromTarget) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget16(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *EventReceivedMessageFromTarget) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget16(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget17(in *jlexer.Lexer, out *EventDetachedFromTarget) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "sessionId":
+			out.SessionID = SessionID(in.String())
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget17(out *jwriter.Writer, in EventDetachedFromTarget) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	{
+		const prefix string = ",\"sessionId\":"
+		out.RawString(prefix[1:])
+		out.String(string(in.SessionID))
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v EventDetachedFromTarget) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget17(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v EventDetachedFromTarget) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget17(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *EventDetachedFromTarget) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget17(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *EventDetachedFromTarget) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget17(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget18(in *jlexer.Lexer, out *EventAttachedToTarget) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "sessionId":
+			out.SessionID = SessionID(in.String())
+		case "targetInfo":
+			if in.IsNull() {
+				in.Skip()
+				out.TargetInfo = nil
+			} else {
+				if out.TargetInfo == nil {
+					out.TargetInfo = new(Info)
+				}
+				(*out.TargetInfo).UnmarshalEasyJSON(in)
+			}
+		case "waitingForDebugger":
+			out.WaitingForDebugger = bool(in.Bool())
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget18(out *jwriter.Writer, in EventAttachedToTarget) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	{
+		const prefix string = ",\"sessionId\":"
+		out.RawString(prefix[1:])
+		out.String(string(in.SessionID))
+	}
+	{
+		const prefix string = ",\"targetInfo\":"
+		out.RawString(prefix)
+		if in.TargetInfo == nil {
+			out.RawString("null")
+		} else {
+			(*in.TargetInfo).MarshalEasyJSON(out)
+		}
+	}
+	{
+		const prefix string = ",\"waitingForDebugger\":"
+		out.RawString(prefix)
+		out.Bool(bool(in.WaitingForDebugger))
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v EventAttachedToTarget) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget18(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v EventAttachedToTarget) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget18(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *EventAttachedToTarget) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget18(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *EventAttachedToTarget) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget18(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget19(in *jlexer.Lexer, out *DisposeBrowserContextParams) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "browserContextId":
+			out.BrowserContextID = cdp.BrowserContextID(in.String())
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget19(out *jwriter.Writer, in DisposeBrowserContextParams) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	{
+		const prefix string = ",\"browserContextId\":"
+		out.RawString(prefix[1:])
+		out.String(string(in.BrowserContextID))
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v DisposeBrowserContextParams) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget19(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v DisposeBrowserContextParams) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget19(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *DisposeBrowserContextParams) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget19(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *DisposeBrowserContextParams) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget19(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget20(in *jlexer.Lexer, out *DetachFromTargetParams) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "sessionId":
+			out.SessionID = SessionID(in.String())
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget20(out *jwriter.Writer, in DetachFromTargetParams) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	if in.SessionID != "" {
+		const prefix string = ",\"sessionId\":"
+		first = false
+		out.RawString(prefix[1:])
+		out.String(string(in.SessionID))
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v DetachFromTargetParams) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget20(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v DetachFromTargetParams) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget20(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *DetachFromTargetParams) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget20(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *DetachFromTargetParams) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget20(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget21(in *jlexer.Lexer, out *CreateTargetReturns) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "targetId":
+			out.TargetID = ID(in.String())
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget21(out *jwriter.Writer, in CreateTargetReturns) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	if in.TargetID != "" {
+		const prefix string = ",\"targetId\":"
+		first = false
+		out.RawString(prefix[1:])
+		out.String(string(in.TargetID))
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v CreateTargetReturns) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget21(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v CreateTargetReturns) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget21(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *CreateTargetReturns) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget21(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *CreateTargetReturns) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget21(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget22(in *jlexer.Lexer, out *CreateTargetParams) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "url":
+			out.URL = string(in.String())
+		case "width":
+			out.Width = int64(in.Int64())
+		case "height":
+			out.Height = int64(in.Int64())
+		case "browserContextId":
+			out.BrowserContextID = cdp.BrowserContextID(in.String())
+		case "enableBeginFrameControl":
+			out.EnableBeginFrameControl = bool(in.Bool())
+		case "newWindow":
+			out.NewWindow = bool(in.Bool())
+		case "background":
+			out.Background = bool(in.Bool())
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget22(out *jwriter.Writer, in CreateTargetParams) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	{
+		const prefix string = ",\"url\":"
+		out.RawString(prefix[1:])
+		out.String(string(in.URL))
+	}
+	if in.Width != 0 {
+		const prefix string = ",\"width\":"
+		out.RawString(prefix)
+		out.Int64(int64(in.Width))
+	}
+	if in.Height != 0 {
+		const prefix string = ",\"height\":"
+		out.RawString(prefix)
+		out.Int64(int64(in.Height))
+	}
+	if in.BrowserContextID != "" {
+		const prefix string = ",\"browserContextId\":"
+		out.RawString(prefix)
+		out.String(string(in.BrowserContextID))
+	}
+	if in.EnableBeginFrameControl {
+		const prefix string = ",\"enableBeginFrameControl\":"
+		out.RawString(prefix)
+		out.Bool(bool(in.EnableBeginFrameControl))
+	}
+	if in.NewWindow {
+		const prefix string = ",\"newWindow\":"
+		out.RawString(prefix)
+		out.Bool(bool(in.NewWindow))
+	}
+	if in.Background {
+		const prefix string = ",\"background\":"
+		out.RawString(prefix)
+		out.Bool(bool(in.Background))
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v CreateTargetParams) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget22(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v CreateTargetParams) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget22(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *CreateTargetParams) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget22(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *CreateTargetParams) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget22(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget23(in *jlexer.Lexer, out *CreateBrowserContextReturns) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "browserContextId":
+			out.BrowserContextID = cdp.BrowserContextID(in.String())
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget23(out *jwriter.Writer, in CreateBrowserContextReturns) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	if in.BrowserContextID != "" {
+		const prefix string = ",\"browserContextId\":"
+		first = false
+		out.RawString(prefix[1:])
+		out.String(string(in.BrowserContextID))
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v CreateBrowserContextReturns) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget23(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v CreateBrowserContextReturns) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget23(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *CreateBrowserContextReturns) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget23(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *CreateBrowserContextReturns) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget23(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget24(in *jlexer.Lexer, out *CreateBrowserContextParams) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "disposeOnDetach":
+			out.DisposeOnDetach = bool(in.Bool())
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget24(out *jwriter.Writer, in CreateBrowserContextParams) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	if in.DisposeOnDetach {
+		const prefix string = ",\"disposeOnDetach\":"
+		first = false
+		out.RawString(prefix[1:])
+		out.Bool(bool(in.DisposeOnDetach))
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v CreateBrowserContextParams) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget24(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v CreateBrowserContextParams) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget24(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *CreateBrowserContextParams) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget24(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *CreateBrowserContextParams) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget24(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget25(in *jlexer.Lexer, out *CloseTargetReturns) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "success":
+			out.Success = bool(in.Bool())
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget25(out *jwriter.Writer, in CloseTargetReturns) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	if in.Success {
+		const prefix string = ",\"success\":"
+		first = false
+		out.RawString(prefix[1:])
+		out.Bool(bool(in.Success))
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v CloseTargetReturns) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget25(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v CloseTargetReturns) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget25(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *CloseTargetReturns) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget25(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *CloseTargetReturns) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget25(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget26(in *jlexer.Lexer, out *CloseTargetParams) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "targetId":
+			out.TargetID = ID(in.String())
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget26(out *jwriter.Writer, in CloseTargetParams) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	{
+		const prefix string = ",\"targetId\":"
+		out.RawString(prefix[1:])
+		out.String(string(in.TargetID))
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v CloseTargetParams) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget26(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v CloseTargetParams) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget26(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *CloseTargetParams) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget26(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *CloseTargetParams) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget26(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget27(in *jlexer.Lexer, out *AttachToTargetReturns) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "sessionId":
+			out.SessionID = SessionID(in.String())
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget27(out *jwriter.Writer, in AttachToTargetReturns) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	if in.SessionID != "" {
+		const prefix string = ",\"sessionId\":"
+		first = false
+		out.RawString(prefix[1:])
+		out.String(string(in.SessionID))
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v AttachToTargetReturns) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget27(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v AttachToTargetReturns) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget27(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *AttachToTargetReturns) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget27(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *AttachToTargetReturns) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget27(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget28(in *jlexer.Lexer, out *AttachToTargetParams) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "targetId":
+			out.TargetID = ID(in.String())
+		case "flatten":
+			out.Flatten = bool(in.Bool())
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget28(out *jwriter.Writer, in AttachToTargetParams) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	{
+		const prefix string = ",\"targetId\":"
+		out.RawString(prefix[1:])
+		out.String(string(in.TargetID))
+	}
+	if in.Flatten {
+		const prefix string = ",\"flatten\":"
+		out.RawString(prefix)
+		out.Bool(bool(in.Flatten))
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v AttachToTargetParams) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget28(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v AttachToTargetParams) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget28(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *AttachToTargetParams) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget28(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *AttachToTargetParams) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget28(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget29(in *jlexer.Lexer, out *AttachToBrowserTargetReturns) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "sessionId":
+			out.SessionID = SessionID(in.String())
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget29(out *jwriter.Writer, in AttachToBrowserTargetReturns) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	if in.SessionID != "" {
+		const prefix string = ",\"sessionId\":"
+		first = false
+		out.RawString(prefix[1:])
+		out.String(string(in.SessionID))
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v AttachToBrowserTargetReturns) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget29(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v AttachToBrowserTargetReturns) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget29(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *AttachToBrowserTargetReturns) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget29(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *AttachToBrowserTargetReturns) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget29(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget30(in *jlexer.Lexer, out *AttachToBrowserTargetParams) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget30(out *jwriter.Writer, in AttachToBrowserTargetParams) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v AttachToBrowserTargetParams) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget30(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v AttachToBrowserTargetParams) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget30(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *AttachToBrowserTargetParams) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget30(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *AttachToBrowserTargetParams) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget30(l, v)
+}
+func easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget31(in *jlexer.Lexer, out *ActivateTargetParams) {
+	isTopLevel := in.IsStart()
+	if in.IsNull() {
+		if isTopLevel {
+			in.Consumed()
+		}
+		in.Skip()
+		return
+	}
+	in.Delim('{')
+	for !in.IsDelim('}') {
+		key := in.UnsafeString()
+		in.WantColon()
+		if in.IsNull() {
+			in.Skip()
+			in.WantComma()
+			continue
+		}
+		switch key {
+		case "targetId":
+			out.TargetID = ID(in.String())
+		default:
+			in.SkipRecursive()
+		}
+		in.WantComma()
+	}
+	in.Delim('}')
+	if isTopLevel {
+		in.Consumed()
+	}
+}
+func easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget31(out *jwriter.Writer, in ActivateTargetParams) {
+	out.RawByte('{')
+	first := true
+	_ = first
+	{
+		const prefix string = ",\"targetId\":"
+		out.RawString(prefix[1:])
+		out.String(string(in.TargetID))
+	}
+	out.RawByte('}')
+}
+
+// MarshalJSON supports json.Marshaler interface
+func (v ActivateTargetParams) MarshalJSON() ([]byte, error) {
+	w := jwriter.Writer{}
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget31(&w, v)
+	return w.Buffer.BuildBytes(), w.Error
+}
+
+// MarshalEasyJSON supports easyjson.Marshaler interface
+func (v ActivateTargetParams) MarshalEasyJSON(w *jwriter.Writer) {
+	easyjsonC5a4559bEncodeGithubComChromedpCdprotoTarget31(w, v)
+}
+
+// UnmarshalJSON supports json.Unmarshaler interface
+func (v *ActivateTargetParams) UnmarshalJSON(data []byte) error {
+	r := jlexer.Lexer{Data: data}
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget31(&r, v)
+	return r.Error()
+}
+
+// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
+func (v *ActivateTargetParams) UnmarshalEasyJSON(l *jlexer.Lexer) {
+	easyjsonC5a4559bDecodeGithubComChromedpCdprotoTarget31(l, v)
+}
diff --git a/vendor/github.com/chromedp/cdproto/target/events.go b/vendor/github.com/chromedp/cdproto/target/events.go
new file mode 100644
index 0000000..114a428
--- /dev/null
+++ b/vendor/github.com/chromedp/cdproto/target/events.go
@@ -0,0 +1,62 @@
+package target
+
+// Code generated by cdproto-gen. DO NOT EDIT.
+
+// EventAttachedToTarget issued when attached to target because of
+// auto-attach or attachToTarget command.
+//
+// See: https://chromedevtools.github.io/devtools-protocol/tot/Target#event-attachedToTarget
+type EventAttachedToTarget struct {
+	SessionID          SessionID `json:"sessionId"` // Identifier assigned to the session used to send/receive messages.
+	TargetInfo         *Info     `json:"targetInfo"`
+	WaitingForDebugger bool      `json:"waitingForDebugger"`
+}
+
+// EventDetachedFromTarget issued when detached from target for any reason
+// (including detachFromTarget command). Can be issued multiple times per target
+// if multiple sessions have been attached to it.
+//
+// See: https://chromedevtools.github.io/devtools-protocol/tot/Target#event-detachedFromTarget
+type EventDetachedFromTarget struct {
+	SessionID SessionID `json:"sessionId"` // Detached session identifier.
+}
+
+// EventReceivedMessageFromTarget notifies about a new protocol message
+// received from the session (as reported in attachedToTarget event).
+//
+// See: https://chromedevtools.github.io/devtools-protocol/tot/Target#event-receivedMessageFromTarget
+type EventReceivedMessageFromTarget struct {
+	SessionID SessionID `json:"sessionId"` // Identifier of a session which sends a message.
+	Message   string    `json:"message"`
+}
+
+// EventTargetCreated issued when a possible inspection target is created.
+//
+// See: https://chromedevtools.github.io/devtools-protocol/tot/Target#event-targetCreated
+type EventTargetCreated struct {
+	TargetInfo *Info `json:"targetInfo"`
+}
+
+// EventTargetDestroyed issued when a target is destroyed.
+//
+// See: https://chromedevtools.github.io/devtools-protocol/tot/Target#event-targetDestroyed
+type EventTargetDestroyed struct {
+	TargetID ID `json:"targetId"`
+}
+
+// EventTargetCrashed issued when a target has crashed.
+//
+// See: https://chromedevtools.github.io/devtools-protocol/tot/Target#event-targetCrashed
+type EventTargetCrashed struct {
+	TargetID  ID     `json:"targetId"`
+	Status    string `json:"status"`    // Termination status type.
+	ErrorCode int64  `json:"errorCode"` // Termination error code.
+}
+
+// EventTargetInfoChanged issued when some information about a target has
+// changed. This only happens between targetCreated and targetDestroyed.
+//
+// See: https://chromedevtools.github.io/devtools-protocol/tot/Target#event-targetInfoChanged
+type EventTargetInfoChanged struct {
+	TargetInfo *Info `json:"targetInfo"`
+}
diff --git a/vendor/github.com/chromedp/cdproto/target/target.go b/vendor/github.com/chromedp/cdproto/target/target.go
new file mode 100644
index 0000000..77df063
--- /dev/null
+++ b/vendor/github.com/chromedp/cdproto/target/target.go
@@ -0,0 +1,577 @@
+// Package target provides the Chrome DevTools Protocol
+// commands, types, and events for the Target domain.
+//
+// Supports additional targets discovery and allows to attach to them.
+//
+// Generated by the cdproto-gen command.
+package target
+
+// Code generated by cdproto-gen. DO NOT EDIT.
+
+import (
+	"context"
+
+	"github.com/chromedp/cdproto/cdp"
+)
+
+// ActivateTargetParams activates (focuses) the target.
+type ActivateTargetParams struct {
+	TargetID ID `json:"targetId"`
+}
+
+// ActivateTarget activates (focuses) the target.
+//
+// See: https://chromedevtools.github.io/devtools-protocol/tot/Target#method-activateTarget
+//
+// parameters:
+//   targetID
+func ActivateTarget(targetID ID) *ActivateTargetParams {
+	return &ActivateTargetParams{
+		TargetID: targetID,
+	}
+}
+
+// Do executes Target.activateTarget against the provided context.
+func (p *ActivateTargetParams) Do(ctx context.Context) (err error) {
+	return cdp.Execute(ctx, CommandActivateTarget, p, nil)
+}
+
+// AttachToTargetParams attaches to the target with given id.
+type AttachToTargetParams struct {
+	TargetID ID   `json:"targetId"`
+	Flatten  bool `json:"flatten,omitempty"` // Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
+}
+
+// AttachToTarget attaches to the target with given id.
+//
+// See: https://chromedevtools.github.io/devtools-protocol/tot/Target#method-attachToTarget
+//
+// parameters:
+//   targetID
+func AttachToTarget(targetID ID) *AttachToTargetParams {
+	return &AttachToTargetParams{
+		TargetID: targetID,
+	}
+}
+
+// WithFlatten enables "flat" access to the session via specifying sessionId
+// attribute in the commands. We plan to make this the default, deprecate
+// non-flattened mode, and eventually retire it. See crbug.com/991325.
+func (p AttachToTargetParams) WithFlatten(flatten bool) *AttachToTargetParams {
+	p.Flatten = flatten
+	return &p
+}
+
+// AttachToTargetReturns return values.
+type AttachToTargetReturns struct {
+	SessionID SessionID `json:"sessionId,omitempty"` // Id assigned to the session.
+}
+
+// Do executes Target.attachToTarget against the provided context.
+//
+// returns:
+//   sessionID - Id assigned to the session.
+func (p *AttachToTargetParams) Do(ctx context.Context) (sessionID SessionID, err error) {
+	// execute
+	var res AttachToTargetReturns
+	err = cdp.Execute(ctx, CommandAttachToTarget, p, &res)
+	if err != nil {
+		return "", err
+	}
+
+	return res.SessionID, nil
+}
+
+// AttachToBrowserTargetParams attaches to the browser target, only uses flat
+// sessionId mode.
+type AttachToBrowserTargetParams struct{}
+
+// AttachToBrowserTarget attaches to the browser target, only uses flat
+// sessionId mode.
+//
+// See: https://chromedevtools.github.io/devtools-protocol/tot/Target#method-attachToBrowserTarget
+func AttachToBrowserTarget() *AttachToBrowserTargetParams {
+	return &AttachToBrowserTargetParams{}
+}
+
+// AttachToBrowserTargetReturns return values.
+type AttachToBrowserTargetReturns struct {
+	SessionID SessionID `json:"sessionId,omitempty"` // Id assigned to the session.
+}
+
+// Do executes Target.attachToBrowserTarget against the provided context.
+//
+// returns:
+//   sessionID - Id assigned to the session.
+func (p *AttachToBrowserTargetParams) Do(ctx context.Context) (sessionID SessionID, err error) {
+	// execute
+	var res AttachToBrowserTargetReturns
+	err = cdp.Execute(ctx, CommandAttachToBrowserTarget, nil, &res)
+	if err != nil {
+		return "", err
+	}
+
+	return res.SessionID, nil
+}
+
+// CloseTargetParams closes the target. If the target is a page that gets
+// closed too.
+type CloseTargetParams struct {
+	TargetID ID `json:"targetId"`
+}
+
+// CloseTarget closes the target. If the target is a page that gets closed
+// too.
+//
+// See: https://chromedevtools.github.io/devtools-protocol/tot/Target#method-closeTarget
+//
+// parameters:
+//   targetID
+func CloseTarget(targetID ID) *CloseTargetParams {
+	return &CloseTargetParams{
+		TargetID: targetID,
+	}
+}
+
+// CloseTargetReturns return values.
+type CloseTargetReturns struct {
+	Success bool `json:"success,omitempty"`
+}
+
+// Do executes Target.closeTarget against the provided context.
+//
+// returns:
+//   success
+func (p *CloseTargetParams) Do(ctx context.Context) (success bool, err error) {
+	// execute
+	var res CloseTargetReturns
+	err = cdp.Execute(ctx, CommandCloseTarget, p, &res)
+	if err != nil {
+		return false, err
+	}
+
+	return res.Success, nil
+}
+
+// ExposeDevToolsProtocolParams inject object to the target's main frame that
+// provides a communication channel with browser target. Injected object will be
+// available as window[bindingName]. The object has the follwing API: -
+// binding.send(json) - a method to send messages over the remote debugging
+// protocol - binding.onmessage = json => handleMessage(json) - a callback that
+// will be called for the protocol notifications and command responses.
+type ExposeDevToolsProtocolParams struct {
+	TargetID    ID     `json:"targetId"`
+	BindingName string `json:"bindingName,omitempty"` // Binding name, 'cdp' if not specified.
+}
+
+// ExposeDevToolsProtocol inject object to the target's main frame that
+// provides a communication channel with browser target. Injected object will be
+// available as window[bindingName]. The object has the follwing API: -
+// binding.send(json) - a method to send messages over the remote debugging
+// protocol - binding.onmessage = json => handleMessage(json) - a callback that
+// will be called for the protocol notifications and command responses.
+//
+// See: https://chromedevtools.github.io/devtools-protocol/tot/Target#method-exposeDevToolsProtocol
+//
+// parameters:
+//   targetID
+func ExposeDevToolsProtocol(targetID ID) *ExposeDevToolsProtocolParams {
+	return &ExposeDevToolsProtocolParams{
+		TargetID: targetID,
+	}
+}
+
+// WithBindingName binding name, 'cdp' if not specified.
+func (p ExposeDevToolsProtocolParams) WithBindingName(bindingName string) *ExposeDevToolsProtocolParams {
+	p.BindingName = bindingName
+	return &p
+}
+
+// Do executes Target.exposeDevToolsProtocol against the provided context.
+func (p *ExposeDevToolsProtocolParams) Do(ctx context.Context) (err error) {
+	return cdp.Execute(ctx, CommandExposeDevToolsProtocol, p, nil)
+}
+
+// CreateBrowserContextParams creates a new empty BrowserContext. Similar to
+// an incognito profile but you can have more than one.
+type CreateBrowserContextParams struct {
+	DisposeOnDetach bool `json:"disposeOnDetach,omitempty"` // If specified, disposes this context when debugging session disconnects.
+}
+
+// CreateBrowserContext creates a new empty BrowserContext. Similar to an
+// incognito profile but you can have more than one.
+//
+// See: https://chromedevtools.github.io/devtools-protocol/tot/Target#method-createBrowserContext
+//
+// parameters:
+func CreateBrowserContext() *CreateBrowserContextParams {
+	return &CreateBrowserContextParams{}
+}
+
+// WithDisposeOnDetach if specified, disposes this context when debugging
+// session disconnects.
+func (p CreateBrowserContextParams) WithDisposeOnDetach(disposeOnDetach bool) *CreateBrowserContextParams {
+	p.DisposeOnDetach = disposeOnDetach
+	return &p
+}
+
+// CreateBrowserContextReturns return values.
+type CreateBrowserContextReturns struct {
+	BrowserContextID cdp.BrowserContextID `json:"browserContextId,omitempty"` // The id of the context created.
+}
+
+// Do executes Target.createBrowserContext against the provided context.
+//
+// returns:
+//   browserContextID - The id of the context created.
+func (p *CreateBrowserContextParams) Do(ctx context.Context) (browserContextID cdp.BrowserContextID, err error) {
+	// execute
+	var res CreateBrowserContextReturns
+	err = cdp.Execute(ctx, CommandCreateBrowserContext, p, &res)
+	if err != nil {
+		return "", err
+	}
+
+	return res.BrowserContextID, nil
+}
+
+// GetBrowserContextsParams returns all browser contexts created with
+// Target.createBrowserContext method.
+type GetBrowserContextsParams struct{}
+
+// GetBrowserContexts returns all browser contexts created with
+// Target.createBrowserContext method.
+//
+// See: https://chromedevtools.github.io/devtools-protocol/tot/Target#method-getBrowserContexts
+func GetBrowserContexts() *GetBrowserContextsParams {
+	return &GetBrowserContextsParams{}
+}
+
+// GetBrowserContextsReturns return values.
+type GetBrowserContextsReturns struct {
+	BrowserContextIds []cdp.BrowserContextID `json:"browserContextIds,omitempty"` // An array of browser context ids.
+}
+
+// Do executes Target.getBrowserContexts against the provided context.
+//
+// returns:
+//   browserContextIds - An array of browser context ids.
+func (p *GetBrowserContextsParams) Do(ctx context.Context) (browserContextIds []cdp.BrowserContextID, err error) {
+	// execute
+	var res GetBrowserContextsReturns
+	err = cdp.Execute(ctx, CommandGetBrowserContexts, nil, &res)
+	if err != nil {
+		return nil, err
+	}
+
+	return res.BrowserContextIds, nil
+}
+
+// CreateTargetParams creates a new page.
+type CreateTargetParams struct {
+	URL                     string               `json:"url"`                               // The initial URL the page will be navigated to.
+	Width                   int64                `json:"width,omitempty"`                   // Frame width in DIP (headless chrome only).
+	Height                  int64                `json:"height,omitempty"`                  // Frame height in DIP (headless chrome only).
+	BrowserContextID        cdp.BrowserContextID `json:"browserContextId,omitempty"`        // The browser context to create the page in.
+	EnableBeginFrameControl bool                 `json:"enableBeginFrameControl,omitempty"` // Whether BeginFrames for this target will be controlled via DevTools (headless chrome only, not supported on MacOS yet, false by default).
+	NewWindow               bool                 `json:"newWindow,omitempty"`               // Whether to create a new Window or Tab (chrome-only, false by default).
+	Background              bool                 `json:"background,omitempty"`              // Whether to create the target in background or foreground (chrome-only, false by default).
+}
+
+// CreateTarget creates a new page.
+//
+// See: https://chromedevtools.github.io/devtools-protocol/tot/Target#method-createTarget
+//
+// parameters:
+//   url - The initial URL the page will be navigated to.
+func CreateTarget(url string) *CreateTargetParams {
+	return &CreateTargetParams{
+		URL: url,
+	}
+}
+
+// WithWidth frame width in DIP (headless chrome only).
+func (p CreateTargetParams) WithWidth(width int64) *CreateTargetParams {
+	p.Width = width
+	return &p
+}
+
+// WithHeight frame height in DIP (headless chrome only).
+func (p CreateTargetParams) WithHeight(height int64) *CreateTargetParams {
+	p.Height = height
+	return &p
+}
+
+// WithBrowserContextID the browser context to create the page in.
+func (p CreateTargetParams) WithBrowserContextID(browserContextID cdp.BrowserContextID) *CreateTargetParams {
+	p.BrowserContextID = browserContextID
+	return &p
+}
+
+// WithEnableBeginFrameControl whether BeginFrames for this target will be
+// controlled via DevTools (headless chrome only, not supported on MacOS yet,
+// false by default).
+func (p CreateTargetParams) WithEnableBeginFrameControl(enableBeginFrameControl bool) *CreateTargetParams {
+	p.EnableBeginFrameControl = enableBeginFrameControl
+	return &p
+}
+
+// WithNewWindow whether to create a new Window or Tab (chrome-only, false by
+// default).
+func (p CreateTargetParams) WithNewWindow(newWindow bool) *CreateTargetParams {
+	p.NewWindow = newWindow
+	return &p
+}
+
+// WithBackground whether to create the target in background or foreground
+// (chrome-only, false by default).
+func (p CreateTargetParams) WithBackground(background bool) *CreateTargetParams {
+	p.Background = background
+	return &p
+}
+
+// CreateTargetReturns return values.
+type CreateTargetReturns struct {
+	TargetID ID `json:"targetId,omitempty"` // The id of the page opened.
+}
+
+// Do executes Target.createTarget against the provided context.
+//
+// returns:
+//   targetID - The id of the page opened.
+func (p *CreateTargetParams) Do(ctx context.Context) (targetID ID, err error) {
+	// execute
+	var res CreateTargetReturns
+	err = cdp.Execute(ctx, CommandCreateTarget, p, &res)
+	if err != nil {
+		return "", err
+	}
+
+	return res.TargetID, nil
+}
+
+// DetachFromTargetParams detaches session with given id.
+type DetachFromTargetParams struct {
+	SessionID SessionID `json:"sessionId,omitempty"` // Session to detach.
+}
+
+// DetachFromTarget detaches session with given id.
+//
+// See: https://chromedevtools.github.io/devtools-protocol/tot/Target#method-detachFromTarget
+//
+// parameters:
+func DetachFromTarget() *DetachFromTargetParams {
+	return &DetachFromTargetParams{}
+}
+
+// WithSessionID session to detach.
+func (p DetachFromTargetParams) WithSessionID(sessionID SessionID) *DetachFromTargetParams {
+	p.SessionID = sessionID
+	return &p
+}
+
+// Do executes Target.detachFromTarget against the provided context.
+func (p *DetachFromTargetParams) Do(ctx context.Context) (err error) {
+	return cdp.Execute(ctx, CommandDetachFromTarget, p, nil)
+}
+
+// DisposeBrowserContextParams deletes a BrowserContext. All the belonging
+// pages will be closed without calling their beforeunload hooks.
+type DisposeBrowserContextParams struct {
+	BrowserContextID cdp.BrowserContextID `json:"browserContextId"`
+}
+
+// DisposeBrowserContext deletes a BrowserContext. All the belonging pages
+// will be closed without calling their beforeunload hooks.
+//
+// See: https://chromedevtools.github.io/devtools-protocol/tot/Target#method-disposeBrowserContext
+//
+// parameters:
+//   browserContextID
+func DisposeBrowserContext(browserContextID cdp.BrowserContextID) *DisposeBrowserContextParams {
+	return &DisposeBrowserContextParams{
+		BrowserContextID: browserContextID,
+	}
+}
+
+// Do executes Target.disposeBrowserContext against the provided context.
+func (p *DisposeBrowserContextParams) Do(ctx context.Context) (err error) {
+	return cdp.Execute(ctx, CommandDisposeBrowserContext, p, nil)
+}
+
+// GetTargetInfoParams returns information about a target.
+type GetTargetInfoParams struct {
+	TargetID ID `json:"targetId,omitempty"`
+}
+
+// GetTargetInfo returns information about a target.
+//
+// See: https://chromedevtools.github.io/devtools-protocol/tot/Target#method-getTargetInfo
+//
+// parameters:
+func GetTargetInfo() *GetTargetInfoParams {
+	return &GetTargetInfoParams{}
+}
+
+// WithTargetID [no description].
+func (p GetTargetInfoParams) WithTargetID(targetID ID) *GetTargetInfoParams {
+	p.TargetID = targetID
+	return &p
+}
+
+// GetTargetInfoReturns return values.
+type GetTargetInfoReturns struct {
+	TargetInfo *Info `json:"targetInfo,omitempty"`
+}
+
+// Do executes Target.getTargetInfo against the provided context.
+//
+// returns:
+//   targetInfo
+func (p *GetTargetInfoParams) Do(ctx context.Context) (targetInfo *Info, err error) {
+	// execute
+	var res GetTargetInfoReturns
+	err = cdp.Execute(ctx, CommandGetTargetInfo, p, &res)
+	if err != nil {
+		return nil, err
+	}
+
+	return res.TargetInfo, nil
+}
+
+// GetTargetsParams retrieves a list of available targets.
+type GetTargetsParams struct{}
+
+// GetTargets retrieves a list of available targets.
+//
+// See: https://chromedevtools.github.io/devtools-protocol/tot/Target#method-getTargets
+func GetTargets() *GetTargetsParams {
+	return &GetTargetsParams{}
+}
+
+// GetTargetsReturns return values.
+type GetTargetsReturns struct {
+	TargetInfos []*Info `json:"targetInfos,omitempty"` // The list of targets.
+}
+
+// Do executes Target.getTargets against the provided context.
+//
+// returns:
+//   targetInfos - The list of targets.
+func (p *GetTargetsParams) Do(ctx context.Context) (targetInfos []*Info, err error) {
+	// execute
+	var res GetTargetsReturns
+	err = cdp.Execute(ctx, CommandGetTargets, nil, &res)
+	if err != nil {
+		return nil, err
+	}
+
+	return res.TargetInfos, nil
+}
+
+// SetAutoAttachParams controls whether to automatically attach to new
+// targets which are considered to be related to this one. When turned on,
+// attaches to all existing related targets as well. When turned off,
+// automatically detaches from all currently attached targets.
+type SetAutoAttachParams struct {
+	AutoAttach             bool `json:"autoAttach"`             // Whether to auto-attach to related targets.
+	WaitForDebuggerOnStart bool `json:"waitForDebuggerOnStart"` // Whether to pause new targets when attaching to them. Use Runtime.runIfWaitingForDebugger to run paused targets.
+	Flatten                bool `json:"flatten,omitempty"`      // Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
+}
+
+// SetAutoAttach controls whether to automatically attach to new targets
+// which are considered to be related to this one. When turned on, attaches to
+// all existing related targets as well. When turned off, automatically detaches
+// from all currently attached targets.
+//
+// See: https://chromedevtools.github.io/devtools-protocol/tot/Target#method-setAutoAttach
+//
+// parameters:
+//   autoAttach - Whether to auto-attach to related targets.
+//   waitForDebuggerOnStart - Whether to pause new targets when attaching to them. Use Runtime.runIfWaitingForDebugger to run paused targets.
+func SetAutoAttach(autoAttach bool, waitForDebuggerOnStart bool) *SetAutoAttachParams {
+	return &SetAutoAttachParams{
+		AutoAttach:             autoAttach,
+		WaitForDebuggerOnStart: waitForDebuggerOnStart,
+	}
+}
+
+// WithFlatten enables "flat" access to the session via specifying sessionId
+// attribute in the commands. We plan to make this the default, deprecate
+// non-flattened mode, and eventually retire it. See crbug.com/991325.
+func (p SetAutoAttachParams) WithFlatten(flatten bool) *SetAutoAttachParams {
+	p.Flatten = flatten
+	return &p
+}
+
+// Do executes Target.setAutoAttach against the provided context.
+func (p *SetAutoAttachParams) Do(ctx context.Context) (err error) {
+	return cdp.Execute(ctx, CommandSetAutoAttach, p, nil)
+}
+
+// SetDiscoverTargetsParams controls whether to discover available targets
+// and notify via targetCreated/targetInfoChanged/targetDestroyed events.
+type SetDiscoverTargetsParams struct {
+	Discover bool `json:"discover"` // Whether to discover available targets.
+}
+
+// SetDiscoverTargets controls whether to discover available targets and
+// notify via targetCreated/targetInfoChanged/targetDestroyed events.
+//
+// See: https://chromedevtools.github.io/devtools-protocol/tot/Target#method-setDiscoverTargets
+//
+// parameters:
+//   discover - Whether to discover available targets.
+func SetDiscoverTargets(discover bool) *SetDiscoverTargetsParams {
+	return &SetDiscoverTargetsParams{
+		Discover: discover,
+	}
+}
+
+// Do executes Target.setDiscoverTargets against the provided context.
+func (p *SetDiscoverTargetsParams) Do(ctx context.Context) (err error) {
+	return cdp.Execute(ctx, CommandSetDiscoverTargets, p, nil)
+}
+
+// SetRemoteLocationsParams enables target discovery for the specified
+// locations, when setDiscoverTargets was set to true.
+type SetRemoteLocationsParams struct {
+	Locations []*RemoteLocation `json:"locations"` // List of remote locations.
+}
+
+// SetRemoteLocations enables target discovery for the specified locations,
+// when setDiscoverTargets was set to true.
+//
+// See: https://chromedevtools.github.io/devtools-protocol/tot/Target#method-setRemoteLocations
+//
+// parameters:
+//   locations - List of remote locations.
+func SetRemoteLocations(locations []*RemoteLocation) *SetRemoteLocationsParams {
+	return &SetRemoteLocationsParams{
+		Locations: locations,
+	}
+}
+
+// Do executes Target.setRemoteLocations against the provided context.
+func (p *SetRemoteLocationsParams) Do(ctx context.Context) (err error) {
+	return cdp.Execute(ctx, CommandSetRemoteLocations, p, nil)
+}
+
+// Command names.
+const (
+	CommandActivateTarget         = "Target.activateTarget"
+	CommandAttachToTarget         = "Target.attachToTarget"
+	CommandAttachToBrowserTarget  = "Target.attachToBrowserTarget"
+	CommandCloseTarget            = "Target.closeTarget"
+	CommandExposeDevToolsProtocol = "Target.exposeDevToolsProtocol"
+	CommandCreateBrowserContext   = "Target.createBrowserContext"
+	CommandGetBrowserContexts     = "Target.getBrowserContexts"
+	CommandCreateTarget           = "Target.createTarget"
+	CommandDetachFromTarget       = "Target.detachFromTarget"
+	CommandDisposeBrowserContext  = "Target.disposeBrowserContext"
+	CommandGetTargetInfo          = "Target.getTargetInfo"
+	CommandGetTargets             = "Target.getTargets"
+	CommandSetAutoAttach          = "Target.setAutoAttach"
+	CommandSetDiscoverTargets     = "Target.setDiscoverTargets"
+	CommandSetRemoteLocations     = "Target.setRemoteLocations"
+)
diff --git a/vendor/github.com/chromedp/cdproto/target/types.go b/vendor/github.com/chromedp/cdproto/target/types.go
new file mode 100644
index 0000000..cf0c905
--- /dev/null
+++ b/vendor/github.com/chromedp/cdproto/target/types.go
@@ -0,0 +1,48 @@
+package target
+
+// Code generated by cdproto-gen. DO NOT EDIT.
+
+import (
+	"github.com/chromedp/cdproto/cdp"
+)
+
+// ID [no description].
+//
+// See: https://chromedevtools.github.io/devtools-protocol/tot/Target#type-TargetID
+type ID string
+
+// String returns the ID as string value.
+func (t ID) String() string {
+	return string(t)
+}
+
+// SessionID unique identifier of attached debugging session.
+//
+// See: https://chromedevtools.github.io/devtools-protocol/tot/Target#type-SessionID
+type SessionID string
+
+// String returns the SessionID as string value.
+func (t SessionID) String() string {
+	return string(t)
+}
+
+// Info [no description].
+//
+// See: https://chromedevtools.github.io/devtools-protocol/tot/Target#type-TargetInfo
+type Info struct {
+	TargetID         ID                   `json:"targetId"`
+	Type             string               `json:"type"`
+	Title            string               `json:"title"`
+	URL              string               `json:"url"`
+	Attached         bool                 `json:"attached"`           // Whether the target has an attached client.
+	OpenerID         ID                   `json:"openerId,omitempty"` // Opener target Id
+	BrowserContextID cdp.BrowserContextID `json:"browserContextId,omitempty"`
+}
+
+// RemoteLocation [no description].
+//
+// See: https://chromedevtools.github.io/devtools-protocol/tot/Target#type-RemoteLocation
+type RemoteLocation struct {
+	Host string `json:"host"`
+	Port int64  `json:"port"`
+}
