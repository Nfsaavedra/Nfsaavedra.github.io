diff --git a/src/main/java/io/github/lukehutch/fastclasspathscanner/scanner/ClasspathElement.java b/src/main/java/io/github/lukehutch/fastclasspathscanner/scanner/ClasspathElement.java
index 17a1244..012a004 100644
--- a/src/main/java/io/github/lukehutch/fastclasspathscanner/scanner/ClasspathElement.java
+++ b/src/main/java/io/github/lukehutch/fastclasspathscanner/scanner/ClasspathElement.java
@@ -143,7 +143,8 @@ abstract class ClasspathElement {
             return null;
         }
         final LogNode logNode = log == null ? null
-                : log.log(canonicalPath, "Scanning " + (isDir ? "directory " : "jarfile ") + classpathRelativePath
+                : log.log(canonicalPath, "Scanning " + (isDir ? "directory " : "jarfile ") + "classpath entry "
+                        + classpathRelativePath
                         + (file.getPath().equals(canonicalPath) ? "" : " ; canonical path: " + canonicalPath));
         final ClasspathElement newInstance = isDir
                 ? new ClasspathElementDir(classpathRelativePath, scanSpec, scanFiles, interruptionChecker, logNode)
diff --git a/src/main/java/io/github/lukehutch/fastclasspathscanner/scanner/ClasspathElementDir.java b/src/main/java/io/github/lukehutch/fastclasspathscanner/scanner/ClasspathElementDir.java
index 5243182..1525c81 100644
--- a/src/main/java/io/github/lukehutch/fastclasspathscanner/scanner/ClasspathElementDir.java
+++ b/src/main/java/io/github/lukehutch/fastclasspathscanner/scanner/ClasspathElementDir.java
@@ -121,7 +121,7 @@ class ClasspathElementDir extends ClasspathElement {
             return;
         }
         final LogNode dirLog = log == null ? null
-                : log.log(canonicalPath, "Scanning directory: " + dir
+                : log.log(canonicalPath, "Scanning subdirectory path: " + dirRelativePath
                         + (dir.getPath().equals(canonicalPath) ? "" : " ; canonical path: " + canonicalPath));
         for (final File fileInDir : filesInDir) {
             if ((entryIdx[0]++ & 0xff) == 0) {
@@ -149,8 +149,8 @@ class ClasspathElementDir extends ClasspathElement {
                     continue;
                 }
 
-                if (log != null) {
-                    log.log("Found whitelisted file: " + fileInDirRelativePath);
+                if (dirLog != null) {
+                    dirLog.log("Found whitelisted file: " + fileInDirRelativePath);
                 }
                 fileToLastModified.put(fileInDir, fileInDir.lastModified());
 
@@ -163,7 +163,7 @@ class ClasspathElementDir extends ClasspathElement {
                 // Match file paths against path patterns
                 for (final FilePathTesterAndMatchProcessorWrapper fileMatcher : //
                 scanSpec.getFilePathTestersAndMatchProcessorWrappers()) {
-                    if (fileMatcher.filePathMatches(classpathElt, fileInDirRelativePath, log)) {
+                    if (fileMatcher.filePathMatches(classpathElt, fileInDirRelativePath, dirLog)) {
                         // File's relative path matches.
                         fileMatches.put(fileMatcher.fileMatchProcessorWrapper,
                                 new ClasspathResourceInDir(classpathElt, fileInDirRelativePath, fileInDir));
diff --git a/src/main/java/io/github/lukehutch/fastclasspathscanner/scanner/ClasspathElementZip.java b/src/main/java/io/github/lukehutch/fastclasspathscanner/scanner/ClasspathElementZip.java
index 7ffb71c..f25f306 100644
--- a/src/main/java/io/github/lukehutch/fastclasspathscanner/scanner/ClasspathElementZip.java
+++ b/src/main/java/io/github/lukehutch/fastclasspathscanner/scanner/ClasspathElementZip.java
@@ -236,7 +236,7 @@ class ClasspathElementZip extends ClasspathElement {
             }
 
             if (log != null) {
-                log.log("Found whitelisted file in jarfile: " + relativePath);
+                log.log("Found whitelisted file: " + relativePath);
             }
 
             // Store relative paths of any classfiles encountered
diff --git a/src/main/java/io/github/lukehutch/fastclasspathscanner/scanner/ClasspathFinder.java b/src/main/java/io/github/lukehutch/fastclasspathscanner/scanner/ClasspathFinder.java
index 231136f..4f58d8a 100644
--- a/src/main/java/io/github/lukehutch/fastclasspathscanner/scanner/ClasspathFinder.java
+++ b/src/main/java/io/github/lukehutch/fastclasspathscanner/scanner/ClasspathFinder.java
@@ -30,18 +30,27 @@ package io.github.lukehutch.fastclasspathscanner.scanner;
 
 import java.io.File;
 import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 
 import io.github.lukehutch.fastclasspathscanner.FastClasspathScanner;
 import io.github.lukehutch.fastclasspathscanner.classloaderhandler.ClassLoaderHandler;
 import io.github.lukehutch.fastclasspathscanner.classloaderhandler.ClassLoaderHandlerRegistry;
 import io.github.lukehutch.fastclasspathscanner.utils.AdditionOrderedSet;
+import io.github.lukehutch.fastclasspathscanner.utils.FileUtils;
+import io.github.lukehutch.fastclasspathscanner.utils.JarUtils;
 import io.github.lukehutch.fastclasspathscanner.utils.LogNode;
+import io.github.lukehutch.fastclasspathscanner.utils.NestedJarHandler;
 
 /** A class to find the unique ordered classpath elements. */
 public class ClasspathFinder {
+    private final NestedJarHandler nestedJarHandler;
+    private static String currDirPathStr = FileUtils.getCurrDirPathStr();
+
     /** The list of raw classpath elements. */
-    private final List<String> rawClasspathElements = new ArrayList<>();
+    private final List<ClasspathRelativePath> rawClasspathElements = new ArrayList<>();
+    private final Set<ClasspathRelativePath> rawClasspathElementsSet = new HashSet<>();
 
     /**
      * Add a classpath element relative to a base file. May be called by a ClassLoaderHandler to add classpath
@@ -51,9 +60,17 @@ public class ClasspathFinder {
      */
     public boolean addClasspathElement(final String pathElement, final LogNode log) {
         if (pathElement != null && !pathElement.isEmpty()) {
-            rawClasspathElements.add(pathElement);
-            if (log != null) {
-                log.log("Adding classpath element: " + pathElement);
+            final ClasspathRelativePath classpathEltPath = new ClasspathRelativePath(currDirPathStr, pathElement,
+                    nestedJarHandler);
+            if (rawClasspathElementsSet.add(classpathEltPath)) {
+                rawClasspathElements.add(classpathEltPath);
+                if (log != null) {
+                    log.log("Found classpath element: " + classpathEltPath);
+                }
+            } else {
+                if (log != null) {
+                    log.log("Ignoring duplicate classpath element: " + classpathEltPath);
+                }
             }
             return true;
         }
@@ -79,7 +96,8 @@ public class ClasspathFinder {
     // -------------------------------------------------------------------------------------------------------------
 
     /** A class to find the unique ordered classpath elements. */
-    ClasspathFinder(final ScanSpec scanSpec, final LogNode log) {
+    ClasspathFinder(final ScanSpec scanSpec, final NestedJarHandler nestedJarHandler, final LogNode log) {
+        this.nestedJarHandler = nestedJarHandler;
         if (scanSpec.overrideClasspath != null) {
             // Manual classpath override
             if (scanSpec.overrideClassLoaders) {
@@ -91,6 +109,16 @@ public class ClasspathFinder {
             final LogNode overrideLog = log == null ? null : log.log("Overriding classpath");
             addClasspathElements(scanSpec.overrideClasspath, overrideLog);
         } else {
+            // If system jars are not blacklisted, need to manually add rt.jar at the beginning of the classpath,
+            // because it is included implicitly by the JVM.
+            if (!scanSpec.blacklistSystemJars()) {
+                // There should only be zero or one of these.
+                final String rtJarPath = JarUtils.getRtJarPath();
+                if (rtJarPath != null) {
+                    // Insert rt.jar as the first entry in the classpath.
+                    addClasspathElement(rtJarPath, log);
+                }
+            }
             // Get all default ClassLoaderHandlers
             final List<ClassLoaderHandler> classLoaderHandlers = new ArrayList<>();
             for (final Class<? extends ClassLoaderHandler> classLoaderHandlerClass : //
@@ -176,7 +204,7 @@ public class ClasspathFinder {
     }
 
     /** Get the raw classpath elements obtained from ClassLoaders. */
-    public List<String> getRawClasspathElements() {
+    public List<ClasspathRelativePath> getRawClasspathElements() {
         return rawClasspathElements;
     }
 
diff --git a/src/main/java/io/github/lukehutch/fastclasspathscanner/scanner/Scanner.java b/src/main/java/io/github/lukehutch/fastclasspathscanner/scanner/Scanner.java
index e1f4dfc..6ddacb1 100644
--- a/src/main/java/io/github/lukehutch/fastclasspathscanner/scanner/Scanner.java
+++ b/src/main/java/io/github/lukehutch/fastclasspathscanner/scanner/Scanner.java
@@ -29,11 +29,6 @@
 package io.github.lukehutch.fastclasspathscanner.scanner;
 
 import java.io.File;
-import java.io.IOException;
-import java.net.URL;
-import java.nio.file.LinkOption;
-import java.nio.file.Path;
-import java.nio.file.Paths;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -46,9 +41,7 @@ import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;
 
-import io.github.lukehutch.fastclasspathscanner.utils.FastPathResolver;
 import io.github.lukehutch.fastclasspathscanner.utils.InterruptionChecker;
-import io.github.lukehutch.fastclasspathscanner.utils.JarUtils;
 import io.github.lukehutch.fastclasspathscanner.utils.LogNode;
 import io.github.lukehutch.fastclasspathscanner.utils.NestedJarHandler;
 import io.github.lukehutch.fastclasspathscanner.utils.Recycler;
@@ -205,95 +198,101 @@ public class Scanner implements Callable<ScanResult> {
     @Override
     public ScanResult call() throws InterruptedException, ExecutionException {
         final LogNode classpathFinderLog = log == null ? null : log.log("Finding classpath entries");
-        this.nestedJarHandler = new NestedJarHandler(interruptionChecker, log);
+        this.nestedJarHandler = new NestedJarHandler(interruptionChecker, classpathFinderLog);
         try {
             final long scanStart = System.nanoTime();
 
-            // Get current dir (without resolving symlinks), and normalize path by calling
-            // FastPathResolver.resolve()
-            String currDirPathStr = "";
-            try {
-                // Done in steps, so we can provide fine-grained debug info if the current dir doesn't exist (#109)
-                Path currDirPath = Paths.get("").toAbsolutePath();
-                currDirPathStr = currDirPath.toString();
-                currDirPath = currDirPath.normalize();
-                currDirPathStr = currDirPath.toString();
-                currDirPath = currDirPath.toRealPath(LinkOption.NOFOLLOW_LINKS);
-                currDirPathStr = currDirPath.toString();
-                currDirPathStr = FastPathResolver.resolve(currDirPathStr);
-            } catch (final IOException e) {
-                throw new RuntimeException("Could not resolve current directory: " + currDirPathStr, e);
-            }
-
             // Get raw classpath elements
-            final List<String> rawClasspathElementPathStrs = new ClasspathFinder(scanSpec, classpathFinderLog)
-                    .getRawClasspathElements();
-
-            // Create ClasspathElement objects for each raw classpath element path
-            final List<ClasspathRelativePath> rawClasspathElements = new ArrayList<>();
-            for (final String rawClasspathElementPathStr : rawClasspathElementPathStrs) {
-                // Resolve classpath elements relative to current dir, so that paths like "." are handled.
-                final ClasspathRelativePath classpathElt = new ClasspathRelativePath(currDirPathStr,
-                        rawClasspathElementPathStr, nestedJarHandler);
-                rawClasspathElements.add(classpathElt);
-            }
+            final LogNode getRawElementsLog = classpathFinderLog == null ? null
+                    : classpathFinderLog.log("Getting raw classpath elements");
+            final List<ClasspathRelativePath> rawClasspathEltPathsDedupd = new ClasspathFinder(scanSpec,
+                    nestedJarHandler, getRawElementsLog).getRawClasspathElements();
 
             // In parallel, resolve raw classpath elements to canonical paths, creating a ClasspathElement
-            // singleton for each unique canonical path.
+            // singleton for each unique canonical path. Also check jars against jar whitelist/blacklist.a
+            final LogNode recursiveScanLog = classpathFinderLog == null ? null
+                    : classpathFinderLog.log("Scanning file names within each classpath element, "
+                            + "while also searching for \"Class-Path:\" entries within manifest files");
             final ClasspathRelativePathToElementMap classpathElementMap = new ClasspathRelativePathToElementMap(
-                    enableRecursiveScanning, scanSpec, nestedJarHandler, interruptionChecker, classpathFinderLog);
-            try (WorkQueue<ClasspathRelativePath> workQueue = new WorkQueue<>(rawClasspathElements,
+                    enableRecursiveScanning, scanSpec, nestedJarHandler, interruptionChecker, recursiveScanLog);
+            try (WorkQueue<ClasspathRelativePath> workQueue = new WorkQueue<>(rawClasspathEltPathsDedupd,
                     new WorkUnitProcessor<ClasspathRelativePath>() {
                         @Override
-                        public void processWorkUnit(ClasspathRelativePath rawClasspathElt) throws Exception {
+                        public void processWorkUnit(ClasspathRelativePath rawClasspathEltPath) throws Exception {
                             // Check if classpath element is already in the singleton map -- saves needlessly
                             // repeating work in isValidClasspathElement() and createSingleton()
-                            if (classpathElementMap.get(rawClasspathElt) != null) {
-                                if (classpathFinderLog != null) {
-                                    classpathFinderLog.log("Ignoring duplicate classpath element: "
-                                            + rawClasspathElt.getResolvedPath());
+                            // (need to check for duplicates again, even though we checked above, since
+                            // additonal classpath entries can come from Class-Path entries in manifests)
+                            if (classpathElementMap.get(rawClasspathEltPath) != null) {
+                                if (recursiveScanLog != null) {
+                                    recursiveScanLog
+                                            .log("Ignoring duplicate classpath element: " + rawClasspathEltPath);
                                 }
-                            } else if (rawClasspathElt.isValidClasspathElement(scanSpec, classpathFinderLog)) {
+                            } else if (rawClasspathEltPath.isValidClasspathElement(scanSpec, recursiveScanLog)) {
                                 try {
-                                    classpathElementMap.createSingleton(rawClasspathElt);
+                                    boolean isFile = rawClasspathEltPath.isFile();
+                                    boolean isDir = rawClasspathEltPath.isDirectory();
+                                    if (isFile && !scanSpec.scanJars) {
+                                        if (recursiveScanLog != null) {
+                                            recursiveScanLog.log("Ignoring because jar scanning has been disabled: "
+                                                    + rawClasspathEltPath);
+                                        }
+                                    } else if (isFile
+                                            && !scanSpec.jarIsWhitelisted(rawClasspathEltPath.toString())) {
+                                        if (recursiveScanLog != null) {
+                                            recursiveScanLog
+                                                    .log("Ignoring jarfile that is blacklisted or not whitelisted: "
+                                                            + rawClasspathEltPath);
+                                        }
+                                    } else if (isDir && !scanSpec.scanDirs) {
+                                        if (recursiveScanLog != null) {
+                                            recursiveScanLog
+                                                    .log("Ignoring because directory scanning has been disabled: "
+                                                            + rawClasspathEltPath);
+                                        }
+                                    } else {
+                                        // Classpath element is valid, add as a singleton.
+                                        // This will trigger calling the ClasspathElementZip constructor in the
+                                        // case of jarfiles, which will check the manifest file for Class-Path
+                                        // entries, and if any are found, additional work units will be added
+                                        // to the work queue to scan those jarfiles too. If Class-Path entries
+                                        // are found, they are added as child elements of the current classpath
+                                        // element, so that they can be inserted at the correct location in the
+                                        // classpath order.
+                                        classpathElementMap.createSingleton(rawClasspathEltPath);
+                                    }
                                 } catch (Exception e) {
                                     // Could not create singleton, probably due to path canonicalization problem
-                                    classpathFinderLog.log("Classpath element " + rawClasspathElt
+                                    recursiveScanLog.log("Classpath element " + rawClasspathEltPath
                                             + " is not valid (" + e + ") -- skipping");
                                 }
                             }
                         }
-                    }, interruptionChecker, classpathFinderLog)) {
+                    }, interruptionChecker, recursiveScanLog)) {
                 classpathElementMap.setWorkQueue(workQueue);
                 // Start workers, then use this thread to do work too, in case there is only one thread
                 // available in the ExecutorService
-                workQueue.startWorkers(executorService, numParallelTasks - 1, classpathFinderLog);
+                workQueue.startWorkers(executorService, numParallelTasks - 1, recursiveScanLog);
                 workQueue.runWorkLoop();
             }
 
             // Determine total ordering of classpath elements, inserting jars referenced in manifest Class-Path
             // entries in-place into the ordering, if they haven't been listed earlier in the classpath already.
-            List<ClasspathElement> classpathOrder = findClasspathOrder(rawClasspathElements, classpathElementMap);
+            final List<ClasspathElement> classpathOrder = findClasspathOrder(rawClasspathEltPathsDedupd,
+                    classpathElementMap);
 
-            // If system jars are not blacklisted, need to manually add rt.jar at the beginning of the classpath,
-            // because it is included implicitly by the JVM.
-            if (!scanSpec.blacklistSystemJars()) {
-                // There should only be zero or one of these.
-                final String rtJarPath = JarUtils.getRtJarPath();
-                if (rtJarPath != null) {
-                    // Insert rt.jar as the zeroth entry in the classpath.
-                    classpathOrder.add(0,
-                            ClasspathElement.newInstance(
-                                    new ClasspathRelativePath(currDirPathStr, rtJarPath, nestedJarHandler),
-                                    enableRecursiveScanning, scanSpec, nestedJarHandler, /* workQueue = */ null,
-                                    interruptionChecker, classpathFinderLog));
+            // Print final classpath element order, after inserting Class-Path entries from manifest files 
+            if (classpathFinderLog != null) {
+                final LogNode logNode = classpathFinderLog.log("Final classpath element order:");
+                for (int i = 0; i < classpathOrder.size(); i++) {
+                    final ClasspathElement classpathElt = classpathOrder.get(i);
+                    logNode.log(i + ": " + classpathElt);
                 }
             }
 
             if (enableRecursiveScanning) {
+                final LogNode maskLog = log == null ? null : log.log("Masking classpath files");
                 final HashSet<String> classpathRelativePathsFound = new HashSet<>();
-                final ArrayList<ClasspathElement> classpathOrderFiltered = new ArrayList<>();
-                final ArrayList<URL> classpathOrderURLsFiltered = new ArrayList<>();
                 for (int classpathIdx = 0; classpathIdx < classpathOrder.size(); classpathIdx++) {
                     final ClasspathElement classpathElement = classpathOrder.get(classpathIdx);
                     // Implement classpath masking -- if the same relative path occurs multiple times in the
@@ -302,50 +301,14 @@ public class Scanner implements Callable<ScanResult> {
                     // dir scanning is enabled, in order to ensure that class references passed into
                     // MatchProcessors are the same as those that would be loaded by standard classloading.
                     // (See bug #100.)
-                    classpathElement.maskFiles(classpathIdx, classpathRelativePathsFound, log);
-
-                    // Check whether a given classpath element should be scheduled for scanning or not.
-                    // A classpath element is not scanned if (1) it is a jar, and jar scanning is disabled,
-                    // or a jar whitelist was provided in the scan spec, and a given jar is not whitelisted;
-                    // (2) it is a directory, and directory scanning is disabled. 
-                    if (classpathElement.classpathElementFile.isFile() && !scanSpec.scanJars) {
-                        if (log != null) {
-                            log.log(String.format("%06d-2", classpathIdx),
-                                    "Ignoring jarfile, because jar scanning has been disabled: "
-                                            + classpathElement.classpathElementFile);
-                        }
-                    } else if (classpathElement.classpathElementFile.isFile()
-                            && !scanSpec.jarIsWhitelisted(classpathElement.classpathElementFile.getName())) {
-                        if (log != null) {
-                            log.log(String.format("%06d-2", classpathIdx),
-                                    "Ignoring jarfile, because it is not whitelisted: "
-                                            + classpathElement.classpathElementFile);
-                        }
-                    } else if (classpathElement.classpathElementFile.isDirectory() && !scanSpec.scanDirs) {
-                        if (log != null) {
-                            log.log(String.format("%06d-2", classpathIdx),
-                                    "Ignoring directory, because directory scanning has been disabled: "
-                                            + classpathElement.classpathElementFile);
-                        }
-                    } else {
-                        classpathOrderFiltered.add(classpathElement);
-                        classpathOrderURLsFiltered.add(classpathElement.classpathElementURL);
-                    }
-                }
-                classpathOrder = classpathOrderFiltered;
-            }
-
-            if (log != null) {
-                final LogNode logNode = log.log("Classpath element order:");
-                for (int i = 0; i < classpathOrder.size(); i++) {
-                    final ClasspathElement classpathElt = classpathOrder.get(i);
-                    logNode.log(i + ": " + classpathElt);
+                    classpathElement.maskFiles(classpathIdx, classpathRelativePathsFound, maskLog);
                 }
             }
 
             ScanResult scanResult;
             if (enableRecursiveScanning) {
                 // Merge the maps from file to timestamp across all classpath elements
+                // (there will be no overlap in keyspace, since file masking was already performed)
                 final Map<File, Long> fileToLastModified = new HashMap<>();
                 for (final ClasspathElement classpathElement : classpathOrder) {
                     fileToLastModified.putAll(classpathElement.fileToLastModified);
@@ -355,6 +318,7 @@ public class Scanner implements Callable<ScanResult> {
                 final ConcurrentLinkedQueue<ClassInfoUnlinked> classInfoUnlinked = //
                         new ConcurrentLinkedQueue<>();
                 final ConcurrentHashMap<String, String> stringInternMap = new ConcurrentHashMap<>();
+                final LogNode classfileScanLog = log == null ? null : log.log("Scanning classfile binary headers");
                 try (final Recycler<ClassfileBinaryParser, RuntimeException> classfileBinaryParserRecycler = //
                         new Recycler<ClassfileBinaryParser, RuntimeException>() {
                             @Override
@@ -372,14 +336,14 @@ public class Scanner implements Callable<ScanResult> {
                                             classfileBinaryParser = classfileBinaryParserRecycler.acquire();
                                             chunk.classpathElement.parseClassfiles(classfileBinaryParser,
                                                     chunk.classfileStartIdx, chunk.classfileEndIdx, stringInternMap,
-                                                    classInfoUnlinked, log);
+                                                    classInfoUnlinked, classfileScanLog);
                                         } finally {
                                             classfileBinaryParserRecycler.release(classfileBinaryParser);
                                             classfileBinaryParser = null;
                                         }
                                     }
-                                }, interruptionChecker, log)) {
-                    workQueue.startWorkers(executorService, numParallelTasks - 1, log);
+                                }, interruptionChecker, classfileScanLog)) {
+                    workQueue.startWorkers(executorService, numParallelTasks - 1, classfileScanLog);
                     workQueue.runWorkLoop();
                 }
 
diff --git a/src/main/java/io/github/lukehutch/fastclasspathscanner/utils/FileUtils.java b/src/main/java/io/github/lukehutch/fastclasspathscanner/utils/FileUtils.java
new file mode 100644
index 0000000..486742d
--- /dev/null
+++ b/src/main/java/io/github/lukehutch/fastclasspathscanner/utils/FileUtils.java
@@ -0,0 +1,56 @@
+/*
+ * This file is part of FastClasspathScanner.
+ * 
+ * Author: Luke Hutchison
+ * 
+ * Hosted at: https://github.com/lukehutch/fast-classpath-scanner
+ * 
+ * --
+ *
+ * The MIT License (MIT)
+ *
+ * Copyright (c) 2017 Luke Hutchison
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without restriction, including without
+ * limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so, subject to the following
+ * conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in all copies or substantial
+ * portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
+ * LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
+ * EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
+ * OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+package io.github.lukehutch.fastclasspathscanner.utils;
+
+import java.io.IOException;
+import java.nio.file.LinkOption;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+
+public class FileUtils {
+    /** Get current dir (without resolving symlinks), and normalize path by calling FastPathResolver.resolve(). */
+    public static String getCurrDirPathStr() {
+        String currDirPathStr = "";
+        try {
+            // The result is moved to currDirPathStr after each step, so we can provide fine-grained debug info
+            // and a best guess at the path, if the current dir doesn't exist (#109), or something goes wrong
+            // while trying to get the current dir path.
+            Path currDirPath = Paths.get("").toAbsolutePath();
+            currDirPathStr = currDirPath.toString();
+            currDirPath = currDirPath.normalize();
+            currDirPathStr = currDirPath.toString();
+            currDirPath = currDirPath.toRealPath(LinkOption.NOFOLLOW_LINKS);
+            currDirPathStr = currDirPath.toString();
+            currDirPathStr = FastPathResolver.resolve(currDirPathStr);
+        } catch (final IOException e) {
+            throw new RuntimeException("Could not resolve current directory: " + currDirPathStr, e);
+        }
+        return currDirPathStr;
+    }
+}
diff --git a/src/main/java/io/github/lukehutch/fastclasspathscanner/utils/JarUtils.java b/src/main/java/io/github/lukehutch/fastclasspathscanner/utils/JarUtils.java
index d542749..69a109f 100644
--- a/src/main/java/io/github/lukehutch/fastclasspathscanner/utils/JarUtils.java
+++ b/src/main/java/io/github/lukehutch/fastclasspathscanner/utils/JarUtils.java
@@ -106,7 +106,7 @@ public class JarUtils {
                 }
             }
         }
-        
+
         // Add special-case path for Mac OS X, this is not always picked up
         // from java.home or java.ext.dirs
         addJREPath(new File("/System/Library/Java"), jrePathsSet);
@@ -158,15 +158,18 @@ public class JarUtils {
 
     /** Returns the leafname of a path. */
     public static String leafName(final String path) {
-        final int lastSlashIdx = File.separatorChar == '/' ? path.lastIndexOf('/')
-                : Math.max(path.lastIndexOf('/'), path.lastIndexOf(File.separatorChar));
+        final int bangIdx = path.indexOf("!");
+        final int endIdx = bangIdx >= 0 ? bangIdx : path.length();
+        int leafStartIdx = 1 + (File.separatorChar == '/' ? path.lastIndexOf('/', endIdx)
+                : Math.max(path.lastIndexOf('/', endIdx), path.lastIndexOf(File.separatorChar, endIdx)));
         // In case of temp files (for jars extracted from within jars), remove the temp filename prefix
         // -- see NestedJarHandler.unzipToTempFile()
         int sepIdx = path.indexOf(NestedJarHandler.TEMP_FILENAME_LEAF_SEPARATOR);
         if (sepIdx >= 0) {
-            sepIdx += NestedJarHandler.TEMP_FILENAME_LEAF_SEPARATOR.length() - 1;
+            sepIdx += NestedJarHandler.TEMP_FILENAME_LEAF_SEPARATOR.length();
         }
-        final int maxIdx = Math.max(lastSlashIdx, sepIdx);
-        return maxIdx < 0 ? path : path.substring(maxIdx + 1);
+        leafStartIdx = Math.max(leafStartIdx, sepIdx);
+        leafStartIdx = Math.min(leafStartIdx, endIdx);
+        return path.substring(leafStartIdx, endIdx);
     }
 }
