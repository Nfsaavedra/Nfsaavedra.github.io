diff --git a/docs/sink-connector-config-options.rst b/docs/sink-connector-config-options.rst
index 26a6998..6231597 100644
--- a/docs/sink-connector-config-options.rst
+++ b/docs/sink-connector-config-options.rst
@@ -28,10 +28,11 @@ Connection
   * Importance: medium
 
 ``http.headers.content.type``
-  The value of Content-Type that will be send with each request.
+  The value of Content-Type that will be send with each request. Must be non-blank.
 
   * Type: string
   * Default: null
+  * Valid Values: Non-blank string
   * Importance: low
 
 ``http.headers.additional``
diff --git a/src/integration-test/java/io/aiven/kafka/connect/http/IntegrationTest.java b/src/integration-test/java/io/aiven/kafka/connect/http/IntegrationTest.java
index f948ef4..fdb8820 100644
--- a/src/integration-test/java/io/aiven/kafka/connect/http/IntegrationTest.java
+++ b/src/integration-test/java/io/aiven/kafka/connect/http/IntegrationTest.java
@@ -64,6 +64,7 @@ final class IntegrationTest {
     private static final String HTTP_PATH = "/send-data-here";
     private static final String AUTHORIZATION = "Bearer some-token";
     private static final String CONTENT_TYPE = "application/json";
+    private static final String CONTENT_TYPE_HEADER = "Content-Type";
 
     private static final String CONNECTOR_NAME = "test-source-connector";
 
@@ -179,6 +180,45 @@ final class IntegrationTest {
 
     @Test
     @Timeout(30)
+    final void testContentTypeHeader() throws ExecutionException, InterruptedException {
+        final HeaderRecorderHandler headerRecorderHandler = new HeaderRecorderHandler();
+        mockServer = new MockServer(HTTP_PATH, CONTENT_TYPE);
+        mockServer.addHandler(headerRecorderHandler);
+        mockServer.start();
+
+        final Map<String, String> config = basicConnectorConfig();
+        config.put("http.authorization.type", "none");
+        config.put("http.headers.content.type", CONTENT_TYPE);
+        config.remove("http.headers.authorization");
+        connectRunner.createConnector(config);
+
+        final List<Future<RecordMetadata>> sendFutures = new ArrayList<>();
+        for (int i = 0; i < 1000; i++) {
+            for (int partition = 0; partition < TEST_TOPIC_PARTITIONS; partition++) {
+                final String key = "key-" + i;
+                final String value = "value-" + i;
+                sendFutures.add(sendMessageAsync(TEST_TOPIC, partition, key, value));
+            }
+        }
+        producer.flush();
+        for (final Future<RecordMetadata> sendFuture : sendFutures) {
+            sendFuture.get();
+        }
+
+        TestUtils.waitForCondition(
+            () -> headerRecorderHandler.recorderHeaders().size() >= 1000,
+            15000,
+            "All requests received by HTTP server"
+        );
+
+        headerRecorderHandler.recorderHeaders().forEach(headers -> {
+            assertTrue(headers.containsKey(CONTENT_TYPE_HEADER));
+            assertEquals(CONTENT_TYPE, headers.get(CONTENT_TYPE_HEADER));
+        });
+    }
+
+    @Test
+    @Timeout(30)
     final void testAdditionalHeaders() throws ExecutionException, InterruptedException {
         final HeaderRecorderHandler headerRecorderHandler = new HeaderRecorderHandler();
         mockServer.addHandler(headerRecorderHandler);
diff --git a/src/integration-test/java/io/aiven/kafka/connect/http/mockserver/MockServer.java b/src/integration-test/java/io/aiven/kafka/connect/http/mockserver/MockServer.java
index cb427bf..56fca31 100644
--- a/src/integration-test/java/io/aiven/kafka/connect/http/mockserver/MockServer.java
+++ b/src/integration-test/java/io/aiven/kafka/connect/http/mockserver/MockServer.java
@@ -54,6 +54,20 @@ public final class MockServer {
         jettyServer.setHandler(this.handlers);
     }
 
+    public MockServer(final String expectedTarget,
+                      final String expectedContentTypeHeader) {
+        this.expectedTarget = expectedTarget;
+        this.expectedContentTypeHeader = expectedContentTypeHeader;
+        this.expectedAuthorizationHeader = "";
+
+        this.handlers = new HandlerList(
+                new ExpectedTargetHandler(),
+                new ExpectedContentTypeHandler()
+        );
+
+        jettyServer.setHandler(this.handlers);
+    }
+
     public void addHandler(final Handler handler) {
         this.handlers.addHandler(handler);
     }
diff --git a/src/main/java/io/aiven/kafka/connect/http/config/HttpSinkConfig.java b/src/main/java/io/aiven/kafka/connect/http/config/HttpSinkConfig.java
index f6a30c2..fce2604 100644
--- a/src/main/java/io/aiven/kafka/connect/http/config/HttpSinkConfig.java
+++ b/src/main/java/io/aiven/kafka/connect/http/config/HttpSinkConfig.java
@@ -150,8 +150,9 @@ public class HttpSinkConfig extends AbstractConfig {
             HTTP_HEADERS_CONTENT_TYPE_CONFIG,
             ConfigDef.Type.STRING,
             null,
+            new NonBlankStringValidator(true),
             ConfigDef.Importance.LOW,
-            "The value of Content-Type that will be send with each request.",
+            "The value of Content-Type that will be send with each request. Must be non-blank.",
             CONNECTION_GROUP,
             groupCounter++,
             ConfigDef.Width.MEDIUM,
diff --git a/src/main/java/io/aiven/kafka/connect/http/config/NonBlankStringValidator.java b/src/main/java/io/aiven/kafka/connect/http/config/NonBlankStringValidator.java
new file mode 100644
index 0000000..7e3e6ea
--- /dev/null
+++ b/src/main/java/io/aiven/kafka/connect/http/config/NonBlankStringValidator.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2021 Aiven Oy
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.aiven.kafka.connect.http.config;
+
+import org.apache.kafka.common.config.ConfigDef;
+import org.apache.kafka.common.config.ConfigException;
+
+public class NonBlankStringValidator implements ConfigDef.Validator {
+    private final boolean skipNullString;
+
+    public NonBlankStringValidator(final boolean skipNullString) {
+        this.skipNullString = skipNullString;
+    }
+
+    @Override
+    public void ensureValid(final String name, final Object value) {
+        if (skipNullString && value == null) {
+            return;
+        }
+
+        if (value == null) {
+            throw new ConfigException(name, null, "can't be null");
+        }
+
+        if (!(value instanceof String)) {
+            throw new ConfigException(name, value, "must be string");
+        }
+
+        final var stringValue = (String) value;
+        if (stringValue.isBlank()) {
+            throw new ConfigException(name, value, "String must be non-blank");
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "Non-blank string";
+    }
+}
diff --git a/src/main/java/io/aiven/kafka/connect/http/sender/HttpRequestBuilder.java b/src/main/java/io/aiven/kafka/connect/http/sender/HttpRequestBuilder.java
index 7d16d90..a5cd34c 100644
--- a/src/main/java/io/aiven/kafka/connect/http/sender/HttpRequestBuilder.java
+++ b/src/main/java/io/aiven/kafka/connect/http/sender/HttpRequestBuilder.java
@@ -33,17 +33,13 @@ interface HttpRequestBuilder {
         final var httpRequest = HttpRequest.newBuilder(config.httpUri())
                 .timeout(Duration.ofSeconds(config.httpTimeout()));
         config.getAdditionalHeaders().forEach(httpRequest::header);
-        return httpRequest;
-    };
-
-    HttpRequestBuilder AUTH_HTTP_REQUEST_BUILDER = config -> {
-        final var requestBuilder =
-                DEFAULT_HTTP_REQUEST_BUILDER.build(config)
-                        .header(HEADER_AUTHORIZATION, config.headerAuthorization());
         if (config.headerContentType() != null) {
-            requestBuilder.header(HEADER_CONTENT_TYPE, config.headerContentType());
+            httpRequest.header(HEADER_CONTENT_TYPE, config.headerContentType());
         }
-        return requestBuilder;
+        return httpRequest;
     };
 
+    HttpRequestBuilder AUTH_HTTP_REQUEST_BUILDER = config -> DEFAULT_HTTP_REQUEST_BUILDER.build(config)
+            .header(HEADER_AUTHORIZATION, config.headerAuthorization());
+
 }
