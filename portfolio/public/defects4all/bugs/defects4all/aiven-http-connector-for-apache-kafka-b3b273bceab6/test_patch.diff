diff --git a/src/test/java/io/aiven/kafka/connect/http/config/HttpSinkConfigValidationTest.java b/src/test/java/io/aiven/kafka/connect/http/config/HttpSinkConfigValidationTest.java
index a2a7a0f..bb6c372 100644
--- a/src/test/java/io/aiven/kafka/connect/http/config/HttpSinkConfigValidationTest.java
+++ b/src/test/java/io/aiven/kafka/connect/http/config/HttpSinkConfigValidationTest.java
@@ -23,10 +23,14 @@ import org.apache.kafka.common.config.ConfigException;
 
 import org.junit.jupiter.api.Test;
 
+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
 import static org.junit.jupiter.api.Assertions.assertIterableEquals;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 
 final class HttpSinkConfigValidationTest {
+
+    private static final String CONTENT_TYPE_VALUE = "application/json";
+
     @Test
     void recommendedValuesForAuthorization() {
         final Map<String, String> properties = Map.of(
@@ -78,4 +82,39 @@ final class HttpSinkConfigValidationTest {
             "Expected config exception due to empty value, but it parsed successfully"
         );
     }
+
+    @Test
+    void checkContentTypeValidation() {
+        final Map<String, String> properties = new HashMap<>(Map.of(
+            "http.url", "http://localhost:8090",
+            "http.authorization.type", "none",
+            "http.headers.content.type", CONTENT_TYPE_VALUE
+        ));
+
+        assertDoesNotThrow(
+            () -> new HttpSinkConfig(properties),
+            "Expected config valid due to valid content type"
+        );
+
+        properties.replace("http.headers.content.type", "");
+        assertThrows(
+            ConfigException.class,
+            () -> new HttpSinkConfig(properties),
+            "Expected config exception due to empty content type"
+        );
+
+        properties.replace("http.headers.content.type", "        ");
+        assertThrows(
+            ConfigException.class,
+            () -> new HttpSinkConfig(properties),
+            "Expected config exception due to blank content type"
+        );
+
+        properties.replace("http.headers.content.type", " \r\n       ");
+        assertThrows(
+            ConfigException.class,
+            () -> new HttpSinkConfig(properties),
+            "Expected config exception due to blank content type"
+        );
+    }
 }
diff --git a/src/test/java/io/aiven/kafka/connect/http/sender/OAuth2HttpSenderTest.java b/src/test/java/io/aiven/kafka/connect/http/sender/OAuth2HttpSenderTest.java
index 4461207..54e6ec9 100644
--- a/src/test/java/io/aiven/kafka/connect/http/sender/OAuth2HttpSenderTest.java
+++ b/src/test/java/io/aiven/kafka/connect/http/sender/OAuth2HttpSenderTest.java
@@ -43,6 +43,7 @@ import org.mockito.stubbing.Answer;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
@@ -52,6 +53,8 @@ import static org.mockito.Mockito.when;
 @MockitoSettings(strictness = Strictness.STRICT_STUBS)
 class OAuth2HttpSenderTest {
 
+    private static final String CONTENT_TYPE_VALUE = "application/json";
+
     @Mock
     HttpClient mockedHttpClient;
 
@@ -122,6 +125,39 @@ class OAuth2HttpSenderTest {
     }
 
     @Test
+    void buildSpecifiedContentType(@Mock final HttpResponse<String> accessTokenResponse)
+            throws IOException, InterruptedException {
+        final var config = new HashMap<>(defaultConfig());
+        config.put("oauth2.client.authorization.mode", "url");
+        config.put("oauth2.client.scope", "a,b,c");
+        config.put("oauth2.response.token.property", "some_token");
+        config.put("http.headers.content.type", CONTENT_TYPE_VALUE);
+
+        final var httpSend =
+                new OAuth2HttpSender(
+                        new HttpSinkConfig(config),
+                        mockedHttpClient
+                );
+
+        final var requestCaptor = ArgumentCaptor.forClass(HttpRequest.class);
+
+        final var accessTokenJson = Map.of(
+                "some_token", "bla-bla-bla-bla",
+                "token_type", "Basic"
+        );
+
+        when(accessTokenResponse.statusCode()).thenReturn(200);
+        when(accessTokenResponse.body()).thenReturn(objectMapper.writeValueAsString(accessTokenJson));
+        when(mockedHttpClient.<String>send(requestCaptor.capture(), any())).thenReturn(accessTokenResponse);
+
+        httpSend.send("SOME_BODY");
+
+        final var r = requestCaptor.getAllValues().get(1);
+        assertTrue(r.headers().firstValue(HttpRequestBuilder.HEADER_CONTENT_TYPE).isPresent());
+        assertEquals(CONTENT_TYPE_VALUE, r.headers().firstValue(HttpRequestBuilder.HEADER_CONTENT_TYPE).get());
+    }
+
+    @Test
     void reuseAccessToken(@Mock final HttpResponse<String> response) throws Exception {
         final var config = defaultConfig();
 
