diff --git a/src/test/java/org/owasp/esapi/reference/HTTPUtilitiesTest.java b/src/test/java/org/owasp/esapi/reference/HTTPUtilitiesTest.java
index 80a7010..2b164db 100644
--- a/src/test/java/org/owasp/esapi/reference/HTTPUtilitiesTest.java
+++ b/src/test/java/org/owasp/esapi/reference/HTTPUtilitiesTest.java
@@ -41,6 +41,7 @@ import org.owasp.esapi.errors.AuthenticationException;
 import org.owasp.esapi.errors.EncryptionException;
 import org.owasp.esapi.errors.EnterpriseSecurityException;
 import org.owasp.esapi.errors.ValidationException;
+import org.owasp.esapi.errors.ValidationUploadException;
 import org.owasp.esapi.http.MockHttpServletRequest;
 import org.owasp.esapi.http.MockHttpServletResponse;
 import org.owasp.esapi.http.MockHttpSession;
@@ -52,6 +53,7 @@ import junit.framework.TestCase;
 import junit.framework.TestSuite;
 import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.assertThat;
+// import org.junit.Ignore;     // Doesn't seem to work with TestSuite.
 import org.junit.Rule;
 import org.junit.rules.ExpectedException;
 /**
@@ -203,7 +205,7 @@ public class HTTPUtilitiesTest extends TestCase
     }
 
     /**
-     * Test of formatHttpRequestForLog method, of class org.owasp.esapi.HTTPUtilities.
+     * Test of getFileUploads() method, of class org.owasp.esapi.HTTPUtilities.
      * @throws IOException
      */
     public void testGetFileUploads() throws Exception {
@@ -264,6 +266,115 @@ public class HTTPUtilitiesTest extends TestCase
 
     }
 
+    /**
+     * Second test of getFileUpload() method, of class org.owasp.esapi.HTTPUtilities.
+     * This one is designed to fail by uploading 3 files. (The max is set to 2 files.)
+     * Based on experimentation with a dummy HTML form to send to localhost:8081
+     * and the captured request caught by running 'nc -l 127.0.0.01 8081', this 'content'
+     * is what it looks like (changing the boundary back 'ridiculous') for the
+     * result of this HTML form:
+     * <pre>
+     *    <!DOCTYPE html>
+     *    <html lang="en-US">
+     *    <head>
+     *        <title>Multifle-upload</title>
+     *    </head>
+     *    <body>
+     *    Upload files...
+     *    <form action="http://127.0.0.1:8081/"
+     *           enctype="multipart/form-data"
+     *           method="POST">
+     *       <p>
+     *       What is your name?
+     *       <input type="text" name="full-name"><br/>
+     *       </p<p><br/>What files are you sending?<br/>
+     *       <label for="file1">File 1:</label>
+     *       <input type="file" id="file1" name="file1"><br/>
+     *       <label for="file2">File 2:</label>
+     *       <input type="file" id="file2" name="file2"><br/>
+     *       <label for="file3">File 3:</label>
+     *       <input type="file" id="file3" name="file3"><br/>
+     *       <br/>
+     *       <input type="submit" value="Send">
+     *       <input type="reset">
+     *       </p>
+     *     </form>
+     *    </body>
+     *    </html>
+     * </pre>
+     * with the 'full-name' field filled in with 'kevin w. wall' and the 3
+     * uploaded files filled in with files named 'aaa.txt', 'bbb.txt', and 'ccc.txt',
+     * respectively and each those file containing created thusly from bash:
+     * <pre>
+     *     $ echo AAA >aaa.txt
+     *     $ echo BBB >bbb.txt
+     *     $ echo CCC >ccc.txt
+     * </pre>
+     * Because we are uploading 3 files, but have the property HttpUtilities.MaxUploadFileCount
+     * set to 2 in 'src/test/resources/esapi/ESAPI.properties', the file upload
+     * attempt via HTTPUtilities.getFileUploads() will result in throwing a ValidationUploadException,
+     * and if you look through the exception stack trace, you can see the
+     * 'Caused by' reason is:
+     *      Caused by: org.apache.commons.fileupload.FileCountLimitExceededException: attachment
+     *          at org.apache.commons.fileupload.FileUploadBase.parseRequest(FileUploadBase.java:367)
+     *          at org.apache.commons.fileupload.servlet.ServletFileUpload.parseRequest(ServletFileUpload.java:113)
+     *          at org.owasp.esapi.reference.DefaultHTTPUtilities.getFileUploads(DefaultHTTPUtilities.java:628)
+     *          ... 23 more
+     * which is as it should be.
+     *
+     */
+    public void testGetFileUploadsTooManyFiles() throws Exception {
+        File home = null;
+
+        System.out.println("testGetFileUploadsTooManyFiles");
+
+        try
+        {
+            home = FileTestUtils.createTmpDirectory(CLASS_NAME);
+            String content =    "Content-Type: multipart/form-data; boundary=ridiculous\r\n\r\n\r\n" +
+                                "--ridiculous\r\n" +
+                                "Content-Disposition: form-data; name=\"full-name\"\r\n\r\n" +
+                                "kevin w wall\r\n" +
+                                "--ridiculous\r\n" +
+                                "Content-Disposition: form-data; name=\"file1\"; filename=\"aaa.txt\"\r\n" +
+                                "Content-Type: text/plain\r\n\r\n" +
+                                "AAA\r\n\r\n" +
+                                "--ridiculous\r\n" +
+                                "Content-Disposition: form-data; name=\"file2\"; filename=\"bbb.txt\"\r\n" +
+                                "Content-Type: text/plain\r\n\r\n" +
+                                "BBB\r\n\r\n" +
+                                "--ridiculous\r\n" +
+                                "Content-Disposition: form-data; name=\"file3\"; filename=\"ccc.txt\"\r\n" +
+                                "Content-Type: text/plain\r\n\r\n" +
+                                "CCC\r\n\r\n" +
+                                "--ridiculous--\r\n\r\n";
+
+            MockHttpServletResponse response = new MockHttpServletResponse();
+            MockHttpServletRequest request1 = new MockHttpServletRequest("/test", content.getBytes(response.getCharacterEncoding()));
+            ESAPI.httpUtilities().setCurrentHTTP(request1, response);
+
+            MockHttpServletRequest request2 = new MockHttpServletRequest("/test", content.getBytes(response.getCharacterEncoding()));
+            request2.setContentType( "multipart/form-data; boundary=ridiculous");
+            ESAPI.httpUtilities().setCurrentHTTP(request2, response);
+            List<File> response2 = new ArrayList<>();
+            boolean caughtExpectedException = false;
+            try {
+                response2 = ESAPI.httpUtilities().getFileUploads(request2, home);
+            } catch( ValidationUploadException vuex ) {
+                caughtExpectedException = true;
+            } finally {
+                response2.forEach(file -> file.delete());
+            }
+                // If this assertion fails, check the property HttpUtilities.MaxUploadFileCount in
+                // 'src/test/resources/esapi/ESAPI.properties' to make sure it is still to 2.
+            assertTrue("Did not catch expected ValidationUploadException because too many files uploaded.", caughtExpectedException );
+        }
+        finally
+        {
+            FileTestUtils.deleteRecursively(home);
+        }
+
+    }
 
 
     /**
@@ -577,5 +688,75 @@ public class HTTPUtilitiesTest extends TestCase
         Float test2 = ESAPI.httpUtilities().getRequestAttribute( request, "testAttribute" );
         assertEquals( test2, 43f );
     }
-}
 
+    /** Test HTTPUtilities.getFileUploads with an unauthenticated (i.e.,
+     *  anonymous) user. In 'src/test/resources/esapi/ESAPI.properties', the
+     *  property 'HttpUtilities.FileUploadAllowAnonymousUser' is set to 'false'.
+     *  This is okay, because as it turns out most (all?) of these tests are
+     *  executed after testCSRFToken(), which creates a users.txt file with
+     *  a random user account name that gets used when
+     *  <pre>
+     *      ESAPI.authenticator().setCurrentUser( user );
+     *  </pre>
+     *  gets called a few lines later. That seems to persist throughout the
+     *  remainder of this test suite. However, this test needs to clear that
+     *  information so that any further HTTP requests are made as an anonymous
+     *  user.
+     *
+     *  However, there is a concern here. I is not clear whether or not this
+     *  would have unintended consequences because I don't this assumptions can
+     *  be made about the specific order these test cases within a test suite
+     *  are executed in.
+     *
+     *  Consequently, I ignoring this specific test by commenting it out for the
+     *  concerns mentioned above. Unfortunately, the @Ignore annotation from
+     *  JUnit 4 doesn't work here; apparently, it doesn't play nicely with the JUnit 3
+     *  construct of
+     *      public static Test suite() {
+     *          return new TestSuite(HTTPUtilitiesTest.class);
+     *      }
+     *
+     *  Note, however, the test does give the expected results and fails the
+     *  upload as intended.
+     */
+/********************* KWWALL Commented Out - Do not delete this comment or test! *************
+    public void testGetFileUploadsUnauthenticatedUser() throws Exception {
+        System.out.print( "testGetFileUploadsUnauthenticatedUser" );
+
+        File home = null;
+
+            // Clear the current user info making it effective an anonymous user again.
+        ESAPI.authenticator().clearCurrent();   // Either this or logout(), but logout may kill the session too.
+
+        try
+        {
+            home = FileTestUtils.createTmpDirectory(CLASS_NAME);
+            String content = "--ridiculous\r\nContent-Disposition: form-data; name=\"upload\"; filename=\"testupload.txt\"\r\nContent-Type: application/octet-stream\r\n\r\nThis is a test of the multipart broadcast system.\r\nThis is only a test.\r\nStop.\r\n\r\n--ridiculous\r\nContent-Disposition: form-data; name=\"submit\"\r\n\r\nSubmit Query\r\n--ridiculous--\r\nEpilogue";
+
+            MockHttpServletResponse response = new MockHttpServletResponse();
+            MockHttpServletRequest request1 = new MockHttpServletRequest("/test", content.getBytes(response.getCharacterEncoding()));
+            ESAPI.httpUtilities().setCurrentHTTP(request1, response);
+
+            MockHttpServletRequest request2 = new MockHttpServletRequest("/test", content.getBytes(response.getCharacterEncoding()));
+            request2.setContentType( "multipart/form-data; boundary=ridiculous");
+            ESAPI.httpUtilities().setCurrentHTTP(request2, response);
+            List<File> response2 = new ArrayList<>();
+            try {
+                response2 = ESAPI.httpUtilities().getFileUploads(request2, home);
+                fail("Expecting an exception here");
+            } catch ( java.security.AccessControlException acex ) {
+                ;   // Expected
+            } catch ( Exception ex ) {
+                fail("Wrong exception type caught: " + ex.getClass().getName() +
+                     ", received, expected java.security.AccessControlException");
+            } finally {
+                response2.forEach(file -> file.delete());
+            }
+        }
+        finally
+        {
+            FileTestUtils.deleteRecursively(home);
+        }
+    }
+********************* KWWALL End Commented Out Code ********************/
+}
diff --git a/src/test/resources/esapi/ESAPI.properties b/src/test/resources/esapi/ESAPI.properties
index d9e12ce..9ab8446 100644
--- a/src/test/resources/esapi/ESAPI.properties
+++ b/src/test/resources/esapi/ESAPI.properties
@@ -373,6 +373,31 @@ HttpUtilities.httpQueryParamValueLength=500
 # File upload configuration
 HttpUtilities.ApprovedUploadExtensions=.pdf,.doc,.docx,.ppt,.pptx,.xls,.xlsx,.rtf,.txt,.jpg,.png
 HttpUtilities.MaxUploadFileBytes=500000000
+# Maximum # of files that can be uploaded per HTTP request.
+# Set to -1 for no maximum. Related to CVE-2023-24998.
+# This is intentionally small for testing purposes.
+HttpUtilities.MaxUploadFileCount=2
+
+# Allowing anonymous users to do file uploads via HTTPUtilities.getFileUploads
+# can make it easier for DoS attacks via uploading files easier. (See Security Bulletin #11,
+# https://github.com/ESAPI/esapi-java-legacy/blob/develop/documentation/ESAPI-security-bulletin11.pdf
+# for details).
+#
+# By default, we allow anonymous users to upload files because we can only rely on
+# ESAPI.authenticator().getCurrentUser() to determine if a user associated
+# with the current HTTP session is authenticated and almost no one uses the
+# ESAPI Authenticator because the reference implementation is just a toy
+# implementation and is not enterprise scalable.
+#
+# If you are using the ESAPI Authenticator (the ESAPI reference implementation
+# or you've implemented your own custom one), then you can set this property value
+# to 'false' to disallow anonymous (i.e., unauthenticated) users to upload
+# files. However, if you are not using the ESAPI Authenticator, then you should
+# probably leave this set to 'false', otherwise you will completely prevent the
+# use of HTTPUtilities.getFileUploads methods.
+#
+HttpUtilities.FileUploadAllowAnonymousUser=false
+
 # Using UTF-8 throughout your stack is highly recommended. That includes your database driver,
 # container, and any other technologies you may be using. Failure to do this may expose you
 # to Unicode transcoding injection attacks. Use of UTF-8 does not hinder internationalization.
