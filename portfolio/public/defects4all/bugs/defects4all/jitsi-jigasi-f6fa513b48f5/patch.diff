diff --git a/src/main/java/org/jitsi/jigasi/JvbConference.java b/src/main/java/org/jitsi/jigasi/JvbConference.java
index 9dbf735..4943310 100644
--- a/src/main/java/org/jitsi/jigasi/JvbConference.java
+++ b/src/main/java/org/jitsi/jigasi/JvbConference.java
@@ -319,6 +319,11 @@ public class JvbConference
     private MuteIqHandler muteIqHandler = null;
 
     /**
+     * The lobby room instance for the room if any.
+     */
+    private Lobby lobby = null;
+
+    /**
      * Creates new instance of <tt>JvbConference</tt>
      * @param gatewaySession the <tt>AbstractGatewaySession</tt> that will be
      *                       using this <tt>JvbConference</tt>.
@@ -904,7 +909,7 @@ public class JvbConference
                                             mainRoomJid = JidCreate.entityBareFrom(roomName);
                                         }
 
-                                        Lobby lobbyRoom = new Lobby(this.xmppProvider,
+                                        this.lobby = new Lobby(this.xmppProvider,
                                                 this.callContext,
                                                 lobbyFullJid,
                                                 mainRoomJid,
@@ -914,7 +919,7 @@ public class JvbConference
                                         logger.info(
                                             callContext + " Lobby enabled by moderator! Will try to join lobby!");
 
-                                        lobbyRoom.join();
+                                        this.lobby.join();
 
                                         return;
                                     }
@@ -1050,6 +1055,13 @@ public class JvbConference
         mucRoom.removeMemberPresenceListener(this);
 
         mucRoom = null;
+
+        if (this.lobby != null)
+        {
+            this.lobby.leave();
+        }
+
+        this.lobby = null;
     }
 
     @Override
@@ -1969,4 +1981,32 @@ public class JvbConference
             return IQ.createResultIQ(muteIq);
         }
     }
+
+    /**
+     * Called whenever password is known. In case of lobby, while waiting in the lobby, the user can enter the password
+     * and that can be signalled through SIP Info messages, and we can leve the lobby and enter the room with the
+     * password received, if the password is wrong we will fail joining and the call will be dropped.
+     *
+     * @param pwd <tt>String</tt> room password.
+     */
+    public void onPasswordReceived(String pwd)
+    {
+        // Check if conference joined before trying...
+        if (this.mucRoom != null)
+        {
+            logger.warn(this.callContext + " Strange received a password after joining the room");
+            return;
+        }
+
+        this.callContext.setRoomPassword(pwd);
+
+        // leave lobby room
+        if (this.lobby != null)
+        {
+            this.lobby.leave();
+        }
+
+        // join conference room
+        joinConferenceRoom();
+    }
 }
diff --git a/src/main/java/org/jitsi/jigasi/SipGatewaySession.java b/src/main/java/org/jitsi/jigasi/SipGatewaySession.java
index d2dca00..95b2361 100644
--- a/src/main/java/org/jitsi/jigasi/SipGatewaySession.java
+++ b/src/main/java/org/jitsi/jigasi/SipGatewaySession.java
@@ -22,6 +22,7 @@ import net.java.sip.communicator.service.protocol.event.*;
 import net.java.sip.communicator.service.protocol.media.*;
 import net.java.sip.communicator.util.Logger;
 import org.jitsi.impl.neomedia.*;
+import org.jitsi.jigasi.sip.*;
 import org.jitsi.jigasi.stats.*;
 import org.jitsi.jigasi.util.*;
 import org.jitsi.service.neomedia.*;
@@ -232,6 +233,11 @@ public class SipGatewaySession
     private boolean startAudioMuted = false;
 
     /**
+     * The sip info protocol used to through pstn.
+     */
+    private final SipInfoJsonProtocol sipInfoJsonProtocol;
+
+    /**
      * Creates new <tt>SipGatewaySession</tt> for given <tt>callResource</tt>
      * and <tt>sipCall</tt>. We already have SIP call instance, so this session
      * can be considered "incoming" SIP session(was created after incoming call
@@ -280,6 +286,8 @@ public class SipGatewaySession
             .getAccountPropertyString(
                 JITSI_MEET_DOMAIN_BASE_HEADER_PROPERTY,
                 JITSI_MEET_DOMAIN_BASE_HEADER_DEFAULT);
+
+        this.sipInfoJsonProtocol = new SipInfoJsonProtocol(jitsiMeetTools);
     }
 
     private void allCallsEnded()
@@ -719,64 +727,84 @@ public class SipGatewaySession
                 return;
             }
 
-            if (!jsonObject.containsKey("type"))
+            int msgId = -1;
+
+            if (jsonObject.containsKey("i"))
             {
-                logger.error(this.callContext + " Unknown json object type!");
-                return;
+                msgId = ((Long)jsonObject.get("i")).intValue();
+                if (logger.isDebugEnabled())
+                {
+                    logger.debug("Received message " + msgId);
+                }
             }
 
-            if (!jsonObject.containsKey("id"))
+            if (jsonObject.containsKey("t"))
             {
-                logger.error(this.callContext + " Unknown json object id!");
-                return;
-            }
+                int messageType = ((Long)jsonObject.get("t")).intValue();
 
-            String id = (String)jsonObject.get("id");
-            String type = (String)jsonObject.get("type");
+                if (messageType == SipInfoJsonProtocol.MESSAGE_TYPE.REQUEST_ROOM_ACCESS)
+                {
+                    String password = this.sipInfoJsonProtocol.getPasswordFromRoomAccessRequest(jsonObject);
+                    this.jvbConference.onPasswordReceived(password);
+                }
+            }
 
-            if (type.equalsIgnoreCase("muteResponse"))
+            if (jsonObject.containsKey("type"))
             {
-                if (!jsonObject.containsKey("status"))
+
+                if (!jsonObject.containsKey("id"))
                 {
-                    logger.error(this.callContext
-                        + " muteResponse without status!");
+                    logger.error(this.callContext + " Unknown json object id!");
                     return;
                 }
 
-                if (((String) jsonObject.get("status")).equalsIgnoreCase("OK"))
-                {
-                    JSONObject data = (JSONObject) jsonObject.get("data");
+                String id = (String)jsonObject.get("id");
+                String type = (String)jsonObject.get("type");
 
-                    boolean bMute = (boolean)data.get("audio");
+                if (type.equalsIgnoreCase("muteResponse"))
+                {
+                    if (!jsonObject.containsKey("status"))
+                    {
+                        logger.error(this.callContext
+                                + " muteResponse without status!");
+                        return;
+                    }
 
-                    // Send presence audio muted
-                    this.jvbConference.setChatRoomAudioMuted(bMute);
-                }
-            }
-            else if (type.equalsIgnoreCase("muteRequest"))
-            {
-                JSONObject data = (JSONObject) jsonObject.get("data");
+                    if (((String) jsonObject.get("status")).equalsIgnoreCase("OK"))
+                    {
+                        JSONObject data = (JSONObject) jsonObject.get("data");
 
-                boolean bAudioMute = (boolean)data.get("audio");
+                        boolean bMute = (boolean)data.get("audio");
 
-                // Send request to jicofo
-                if (jvbConference.requestAudioMute(bAudioMute))
-                {
-                    // Send response through sip
-                    respondRemoteAudioMute(bAudioMute,
-                                            true,
-                                            callPeer,
-                                            id);
-
-                    // Send presence if response succeeded
-                    this.jvbConference.setChatRoomAudioMuted(bAudioMute);
+                        // Send presence audio muted
+                        this.jvbConference.setChatRoomAudioMuted(bMute);
+                    }
                 }
-                else
+                else if (type.equalsIgnoreCase("muteRequest"))
                 {
-                    respondRemoteAudioMute(bAudioMute,
-                                            false,
-                                            callPeer,
-                                            id);
+                    JSONObject data = (JSONObject) jsonObject.get("data");
+
+                    boolean bAudioMute = (boolean)data.get("audio");
+
+                    // Send request to jicofo
+                    if (jvbConference.requestAudioMute(bAudioMute))
+                    {
+                        // Send response through sip
+                        respondRemoteAudioMute(bAudioMute,
+                                true,
+                                callPeer,
+                                id);
+
+                        // Send presence if response succeeded
+                        this.jvbConference.setChatRoomAudioMuted(bAudioMute);
+                    }
+                    else
+                    {
+                        respondRemoteAudioMute(bAudioMute,
+                                false,
+                                callPeer,
+                                id);
+                    }
                 }
             }
         }
@@ -806,13 +834,13 @@ public class SipGatewaySession
     /**
      * Creates a JSONObject to request audio to be muted over SIP.
      *
-     * @param bMuted <tt>true</tt> if audio is to be muted, <tt>false</tt> otherwise.
+     * @param muted <tt>true</tt> if audio is to be muted, <tt>false</tt> otherwise.
      * @return Formed JSONObject.
      */
-    private JSONObject createSIPJSONAudioMuteRequest(boolean bMuted)
+    private JSONObject createSIPJSONAudioMuteRequest(boolean muted)
     {
         JSONObject muteSettingsJson = new JSONObject();
-        muteSettingsJson.put("audio", bMuted);
+        muteSettingsJson.put("audio", muted);
 
         return createSIPJSON("muteRequest", muteSettingsJson, null);
     }
@@ -820,17 +848,17 @@ public class SipGatewaySession
     /**
      * Creates a JSONObject as response to a muteRequest.
      *
-     * @param bMuted <tt>true</tt> if audio was muted, <tt>false</tt> otherwise.
+     * @param muted <tt>true</tt> if audio was muted, <tt>false</tt> otherwise.
      * @param bSucceeded <tt>true</tt> if muteRequest succeeded, <tt>false</tt> otherwise.
      * @param id Represents id of muteRequest.
      * @return Formed JSONObject.
      */
-    private JSONObject createSIPJSONAudioMuteResponse(boolean bMuted,
+    private JSONObject createSIPJSONAudioMuteResponse(boolean muted,
                                                         boolean bSucceeded,
                                                         String id)
     {
         JSONObject muteSettingsJson = new JSONObject();
-        muteSettingsJson.put("audio", bMuted);
+        muteSettingsJson.put("audio", muted);
         JSONObject muteResponseJson
             = createSIPJSON("muteResponse", muteSettingsJson, id);
         muteResponseJson.put("status", bSucceeded ? "OK" : "FAILED");
@@ -838,42 +866,42 @@ public class SipGatewaySession
     }
 
     /**
-     * Sends a JSON request over SIP to mute callPeer with bMuted flag.
+     * Sends a JSON request over SIP to mute callPeer with muted flag.
      *
-     * @param bMuted true if audio should be muted, false otherwise.
+     * @param muted true if audio should be muted, false otherwise.
      * @param callPeer CallPeer to send JSON to.
      * @throws OperationFailedException
      */
-    private void requestRemoteAudioMute(boolean bMuted, CallPeer callPeer)
+    private void requestRemoteAudioMute(boolean muted, CallPeer callPeer)
         throws OperationFailedException
     {
         // Mute audio
-        JSONObject muteRequestJson = createSIPJSONAudioMuteRequest(bMuted);
+        JSONObject muteRequestJson = createSIPJSONAudioMuteRequest(muted);
 
         jitsiMeetTools.sendJSON(callPeer,
                                 muteRequestJson,
                                 new HashMap<String, Object>(){{
-                                    put("VIA", (Object)("SIP.INFO"));
+                                    put("VIA", "SIP.INFO");
                                 }});
     }
 
     /**
      * Sends a JSON muteResponse over SIP to callPeer with specified flag.
      *
-     * @param bMuted true if audio was muted, false otherwise.
+     * @param muted true if audio was muted, false otherwise.
      * @param bSucceeded <tt>true</tt> if request succeeded, <tt>false</tt> otherwise.
      * @param callPeer CallPeer to send response to.
      * @param id Set as muteRequest id.
      * @throws OperationFailedException
      */
-    private void respondRemoteAudioMute(boolean bMuted,
+    private void respondRemoteAudioMute(boolean muted,
                                         boolean bSucceeded,
                                         CallPeer callPeer,
                                         String id)
         throws OperationFailedException
     {
         JSONObject muteResponseJson
-            = createSIPJSONAudioMuteResponse(bMuted, bSucceeded, id);
+            = createSIPJSONAudioMuteResponse(muted, bSucceeded, id);
 
         jitsiMeetTools.sendJSON(callPeer,
                                 muteResponseJson,
@@ -1190,6 +1218,8 @@ public class SipGatewaySession
         {
             soundNotificationManager.notifyLobbyWaitReview();
         }
+
+        this.notifyLobbyJoined();
     }
 
     /**
@@ -1328,6 +1358,94 @@ public class SipGatewaySession
     }
 
     /**
+     * Notifies received call that lobby was joined.
+     */
+    public void notifyLobbyJoined()
+    {
+        // Notify peer
+        CallPeer callPeer = sipCall.getCallPeers().next();
+
+        try
+        {
+            if (this.sipInfoJsonProtocol != null)
+            {
+                JSONObject request = this.sipInfoJsonProtocol.createLobbyJoinedNotification();
+                this.sipInfoJsonProtocol.sendJson(callPeer, request);
+            }
+        }
+        catch (Exception ex)
+        {
+            logger.error(this.callContext + " " + ex.getMessage());
+        }
+    }
+
+    /**
+     * Notifies received call that lobby was left.
+     */
+    public void notifyLobbyLeft()
+    {
+        // Notify peer
+        CallPeer callPeer = sipCall.getCallPeers().next();
+
+        try
+        {
+            if (this.sipInfoJsonProtocol != null)
+            {
+                JSONObject request = this.sipInfoJsonProtocol.createLobbyLeftNotification();
+                this.sipInfoJsonProtocol.sendJson(callPeer, request);
+            }
+        }
+        catch (Exception ex)
+        {
+            logger.error(this.callContext + " " + ex.getMessage());
+        }
+    }
+
+    /**
+     * Notifies received call that user was allowed to join while in lobby.
+     */
+    public void notifyLobbyAllowedJoin()
+    {
+        // Notify peer
+        CallPeer callPeer = sipCall.getCallPeers().next();
+
+        try
+        {
+            if (this.sipInfoJsonProtocol != null)
+            {
+                JSONObject request = this.sipInfoJsonProtocol.createLobbyAllowedJoinNotification();
+                this.sipInfoJsonProtocol.sendJson(callPeer, request);
+            }
+        }
+        catch (Exception ex)
+        {
+            logger.error(this.callContext + " " + ex.getMessage());
+        }
+    }
+
+    /**
+     * Notify received call that user was rejected to join while in lobby.
+     */
+    public void notifyLobbyRejectedJoin()
+    {
+        // Notify peer
+        CallPeer callPeer = sipCall.getCallPeers().next();
+
+        try
+        {
+            if (this.sipInfoJsonProtocol != null)
+            {
+                JSONObject request = this.sipInfoJsonProtocol.createLobbyRejectedJoinNotification();
+                this.sipInfoJsonProtocol.sendJson(callPeer, request);
+            }
+        }
+        catch (Exception ex)
+        {
+            logger.error(this.callContext + " " + ex.getMessage());
+        }
+    }
+
+    /**
      * PeriodicRunnable that will check incoming RTP and if needed to hangup.
      */
     private class ExpireMediaStream
diff --git a/src/main/java/org/jitsi/jigasi/SoundNotificationManager.java b/src/main/java/org/jitsi/jigasi/SoundNotificationManager.java
index 6ca3325..d7ace17 100644
--- a/src/main/java/org/jitsi/jigasi/SoundNotificationManager.java
+++ b/src/main/java/org/jitsi/jigasi/SoundNotificationManager.java
@@ -656,6 +656,16 @@ public class SoundNotificationManager
                             },
                             playbackDuration);
                 }
+                else if (fileName.equals(LOBBY_JOIN_REVIEW))
+                {
+                    long playbackDuration = playbackFileDuration.get(fileName).longValue();
+
+                    playbackQueue.queueNext(
+                            gatewaySession.getSipCall(),
+                            fileName,
+                            null,
+                            playbackDuration);
+                }
                 else
                 {
                     playbackQueue.queueNext(gatewaySession.getSipCall(), fileName);
@@ -851,7 +861,7 @@ public class SoundNotificationManager
     /**
      * Implements RateLimiter for sound notifications.
      */
-    private class SoundRateLimiter implements RateLimiter
+    private static class SoundRateLimiter implements RateLimiter
     {
         /**
          * Initial time point.
@@ -1031,7 +1041,7 @@ public class SoundNotificationManager
         /**
          * Queue used to schedule sound notifications.
          */
-        private final BlockingQueue<PlaybackData> playbackQueue = new ArrayBlockingQueue<PlaybackData>(20, true);
+        private final BlockingQueue<PlaybackData> playbackQueue = new ArrayBlockingQueue<>(20, true);
 
         /**
          * Flag used to stop the queue thread.
@@ -1086,8 +1096,9 @@ public class SoundNotificationManager
         @Override
         public void run()
         {
-            while(playbackQueueStopFlag.get() == false)
+            while(!playbackQueueStopFlag.get())
             {
+                Call playbackCall = null;
                 try
                 {
                     PlaybackData playbackData
@@ -1095,31 +1106,31 @@ public class SoundNotificationManager
 
                     if (playbackData != null)
                     {
-                        Call playbackCall = playbackData.getPlaybackCall();
+                        playbackCall = playbackData.getPlaybackCall();
 
-                        injectSoundFile(playbackCall, playbackData.getPlaybackFileName());
+                        if (playbackCall != null)
+                        {
+                            injectSoundFile(playbackCall, playbackData.getPlaybackFileName());
+                        }
 
                         final PlaybackDelegate playbackDelegate = playbackData.getPlaybackDelegate();
                         if (playbackDelegate != null)
                         {
-                            // Start new Timer
-                            new Thread( () -> {
-                                try
-                                {
-                                    Thread.sleep(playbackData.getPlaybackDurationSeconds() * 1000);
-                                    playbackDelegate.onPlaybackFinished();
-                                }
-                                catch (Exception ex)
-                                {
-                                    logger.error(playbackCall.getData(CallContext.class) + " " + ex.toString(), ex);
-                                }
-                            }).start();
+                            playbackDelegate.onPlaybackFinished();
                         }
                     }
                 }
-                catch (InterruptedException e)
+                catch (Exception ex)
                 {
-                    logger.error(e.toString(), e);
+                    if (playbackCall != null)
+                    {
+                        Object callContext = playbackCall.getData(CallContext.class);
+                        logger.error(callContext + " " + ex.toString(), ex);
+                    }
+                    else
+                    {
+                        logger.error(ex.toString());
+                    }
                 }
             }
         }
@@ -1154,11 +1165,9 @@ public class SoundNotificationManager
                 return;
             }
 
-            final MediaStream streamToPass = stream;
-
             try
             {
-                injectSoundFileInStream(streamToPass, fileName);
+                injectSoundFileInStream(stream, fileName);
             }
             catch (Throwable t)
             {
diff --git a/src/main/java/org/jitsi/jigasi/lobby/Lobby.java b/src/main/java/org/jitsi/jigasi/lobby/Lobby.java
index 67d40d8..eda85c1 100644
--- a/src/main/java/org/jitsi/jigasi/lobby/Lobby.java
+++ b/src/main/java/org/jitsi/jigasi/lobby/Lobby.java
@@ -86,12 +86,12 @@ public class Lobby
     /**
      * <tt>JvbConference</tt> Handles JVB conference events and connections.
      */
-    private JvbConference jvbConference = null;
+    private final JvbConference jvbConference;
 
     /**
      * <tt>SipGatewaySession</tt> Handles SIP events and connections.
      */
-    private SipGatewaySession sipGatewaySession = null;
+    private final SipGatewaySession sipGatewaySession;
 
     /**
      * Creates a new instance of <tt>Lobby</tt>
@@ -129,7 +129,8 @@ public class Lobby
      * @throws OperationNotSupportedException
      */
     public void join()
-        throws OperationFailedException, OperationNotSupportedException
+            throws OperationFailedException,
+            OperationNotSupportedException
     {
         joinRoom(getRoomJid());
 
@@ -152,8 +153,6 @@ public class Lobby
 
         muc.addPresenceListener(this);
 
-        ProtocolProviderService pps = getProtocolProvider();
-
         ChatRoom mucRoom = muc.findRoom(roomJid.toString());
 
         setupChatRoom(mucRoom);
@@ -180,14 +179,14 @@ public class Lobby
 
         muc.removeInvitationListener(this);
 
+        muc.removePresenceListener(this);
+
         if (mucRoom == null)
         {
             logger.warn(getCallContext() + " MUC room is null");
             return;
         }
 
-        muc.removePresenceListener(this);
-
         mucRoom.leave();
 
         mucRoom = null;
@@ -210,8 +209,7 @@ public class Lobby
                 callContext.setRoomPassword(new String(pass));
             }
 
-            this.sipGatewaySession.getSoundNotificationManager()
-                    .notifyLobbyAccessGranted();
+            this.notifyAccessGranted();
 
             if (this.jvbConference != null)
             {
@@ -231,6 +229,18 @@ public class Lobby
     }
 
     /**
+     * Access granted, notifies sound manager and sip gw session.
+     */
+    private void notifyAccessGranted()
+    {
+        this.sipGatewaySession.getSoundNotificationManager()
+            .notifyLobbyAccessGranted();
+
+        this.sipGatewaySession.notifyLobbyAllowedJoin();
+        this.sipGatewaySession.notifyLobbyLeft();
+    }
+
+    /**
      * Participant is kicked if rejected on join and this method handles the lobby rejection and lobby room destruction.
      * Participant receives LOCAL_USER_LEFT if lobby is disabled.
      *
@@ -251,6 +261,8 @@ public class Lobby
                      */
                     soundManager.notifyLobbyAccessDenied();
 
+                    sipGatewaySession.notifyLobbyRejectedJoin();
+
                     leave();
 
                     return;
@@ -288,8 +300,6 @@ public class Lobby
                     if (alternateAddress == null)
                     {
                         soundManager.notifyLobbyRoomDestroyed();
-
-                        return;
                     }
                     else
                     {
@@ -298,8 +308,6 @@ public class Lobby
                          */
                         accessGranted(alternateAddress);
                     }
-
-                    return;
                 }
             }
         }
@@ -338,7 +346,7 @@ public class Lobby
             logger.error(getCallContext() + " Error leaving lobby", e);
         }
 
-        this.sipGatewaySession.getSoundNotificationManager().notifyLobbyAccessGranted();
+        this.notifyAccessGranted();
 
         /**
          * The left event is used here in case the lobby is disabled.
diff --git a/src/main/java/org/jitsi/jigasi/sip/SipInfoJsonProtocol.java b/src/main/java/org/jitsi/jigasi/sip/SipInfoJsonProtocol.java
new file mode 100644
index 0000000..04b8738
--- /dev/null
+++ b/src/main/java/org/jitsi/jigasi/sip/SipInfoJsonProtocol.java
@@ -0,0 +1,203 @@
+/*
+ * Jigasi, the JItsi GAteway to SIP.
+ *
+ * Copyright @ 2018 - present 8x8, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.jitsi.jigasi.sip;
+
+import net.java.sip.communicator.service.protocol.*;
+import net.java.sip.communicator.util.*;
+
+import org.json.simple.*;
+
+import java.util.*;
+
+/**
+ *
+ * Message JSON format
+ *
+ * Mandatory header :
+ *
+ * {
+ *      i: <Message Id>,
+ *      t: <Message Type>,
+ *      d: <Data>
+ * }
+ *
+ * <Message Type> integer to identify message type. This integer should be documented.
+ *
+ * <Message Id> simple integer counter
+ *
+ * <Data> OPTIONAL data can be any type respecting the message format.
+ *
+ * This class is used to define sip info protocol.
+ */
+public class SipInfoJsonProtocol
+{
+    /**
+     * The logger.
+     */
+    private final static Logger logger = Logger.getLogger(SipInfoJsonProtocol.class);
+
+    /**
+     * The message types to be used when creating a new message for sip info.
+     */
+    public static class MESSAGE_TYPE
+    {
+        public static final int LOBBY_JOINED = 3;
+        public static final int REQUEST_ROOM_ACCESS = 4;
+        public static final int LOBBY_LEFT = 5;
+        public static final int LOBBY_ALLOWED_JOIN = 6;
+        public static final int LOBBY_REJECTED_JOIN = 7;
+    }
+
+    private static class MESSAGE_HEADER
+    {
+        public static final String MESSAGE_ID = "i";
+        public static final String MESSAGE_TYPE = "t";
+        public static final String MESSAGE_DATA = "d";
+    }
+
+    /**
+     * Message counter used for message id.
+     */
+    private int messageCount = 0;
+
+    /**
+     * The {@link OperationSetJitsiMeetTools} for SIP leg.
+     */
+    private final OperationSetJitsiMeetTools jitsiMeetTools;
+
+    /**
+     * Constructor.
+     *
+     * @param jmt Jitsi operation set to use for communication.
+     */
+    public SipInfoJsonProtocol(OperationSetJitsiMeetTools jmt)
+    {
+        jitsiMeetTools = jmt;
+    }
+
+    /**
+     * @return current message count.
+     */
+    private int getMessageCount()
+    {
+        return messageCount++;
+    }
+
+    /**
+     * Sends a SIP INFO with json payload.
+     *
+     * @param callPeer CallPeer to send the info message.
+     * @param jsonObject JSONObject to be sent.
+     * @throws OperationFailedException failed sending the json.
+     */
+    public void sendJson(CallPeer callPeer, JSONObject jsonObject)
+        throws OperationFailedException
+    {
+        try
+        {
+            jitsiMeetTools.sendJSON(callPeer,
+                    jsonObject,
+                    new HashMap<String, Object>(){{
+                        put("VIA", "SIP.INFO");
+                    }});
+        }
+        catch (Exception ex)
+        {
+            int msgId = -1;
+            if (jsonObject.containsKey(MESSAGE_HEADER.MESSAGE_ID))
+            {
+                msgId = (int)jsonObject.get(MESSAGE_HEADER.MESSAGE_ID);
+            }
+
+            logger.error("Error when sending message " + msgId);
+            throw ex;
+        }
+    }
+
+    /**
+     * Returns the password from a REQUEST_ROOM_ACCESS request type.
+     *
+     * @param request JSONObject that represents a room access request.
+     * @return String that represents a password.
+     */
+    public String getPasswordFromRoomAccessRequest(JSONObject request)
+    {
+        String roomPwd = null;
+        if (request.containsKey(MESSAGE_HEADER.MESSAGE_DATA))
+        {
+            JSONObject jsonData = (JSONObject)request.get(MESSAGE_HEADER.MESSAGE_DATA);
+            if (jsonData.containsKey("pwd"))
+            {
+                roomPwd = (String)jsonData.get("pwd");
+            }
+        }
+        return roomPwd;
+    }
+
+    /**
+     * Creates new JSONObject to notify lobby was joined.
+     *
+     * @return JSONObject representing a message to be sent over SIP.
+     */
+    public JSONObject createLobbyJoinedNotification()
+    {
+        JSONObject lobbyInitJson = new JSONObject();
+        lobbyInitJson.put(MESSAGE_HEADER.MESSAGE_ID, getMessageCount());
+        lobbyInitJson.put(MESSAGE_HEADER.MESSAGE_TYPE, MESSAGE_TYPE.LOBBY_JOINED);
+        return lobbyInitJson;
+    }
+
+    /**
+     * Creates new JSONObject to notify lobby was left.
+     *
+     * @return JSONObject representing a message to be sent over SIP.
+     */
+    public JSONObject createLobbyLeftNotification()
+    {
+        JSONObject lobbyLeftJson = new JSONObject();
+        lobbyLeftJson.put(MESSAGE_HEADER.MESSAGE_ID, getMessageCount());
+        lobbyLeftJson.put(MESSAGE_HEADER.MESSAGE_TYPE, MESSAGE_TYPE.LOBBY_LEFT);
+        return lobbyLeftJson;
+    }
+
+    /**
+     * Create new JSONObject to notify user was allowed to join the main room.
+     *
+     * @return JSONObject representing a message to be sent over SIP.
+     */
+    public JSONObject createLobbyAllowedJoinNotification()
+    {
+        JSONObject lobbyAllowedJson = new JSONObject();
+        lobbyAllowedJson.put(MESSAGE_HEADER.MESSAGE_ID, getMessageCount());
+        lobbyAllowedJson.put(MESSAGE_HEADER.MESSAGE_TYPE, MESSAGE_TYPE.LOBBY_ALLOWED_JOIN);
+        return lobbyAllowedJson;
+    }
+
+    /**
+     * Create new JSONObject to notify user was rejected to join main room.
+     *
+     * @return JSONObject representing a message to be sent over SIP.
+     */
+    public JSONObject createLobbyRejectedJoinNotification()
+    {
+        JSONObject lobbyRejectedJson = new JSONObject();
+        lobbyRejectedJson.put(MESSAGE_HEADER.MESSAGE_ID, getMessageCount());
+        lobbyRejectedJson.put(MESSAGE_HEADER.MESSAGE_TYPE, MESSAGE_TYPE.LOBBY_REJECTED_JOIN);
+        return lobbyRejectedJson;
+    }
+}
