diff --git a/src/main/java/com/github/pedrovgs/problem10/RemoveDuplicates.java b/src/main/java/com/github/pedrovgs/problem10/RemoveDuplicates.java
index e9b0ab7..aaf1a93 100644
--- a/src/main/java/com/github/pedrovgs/problem10/RemoveDuplicates.java
+++ b/src/main/java/com/github/pedrovgs/problem10/RemoveDuplicates.java
@@ -26,7 +26,7 @@ import java.util.Set;
  * Given an array full of integers, can you write a method returning other array without duplicated
  * elements? The elements order doesn't care. For example:
  *
- * Input: [1,2,3,1] Output: [1,1,12]
+ * Input: [1,2,3,1] Output: [1,2,3]
  * Input: [1,1,1,1,1] Output: [1]
  *
  * @author Pedro Vicente Gómez Sánchez.
diff --git a/src/main/java/com/github/pedrovgs/problem12/MoveZerosInArray.java b/src/main/java/com/github/pedrovgs/problem12/MoveZerosInArray.java
index a8e942a..ab63ed3 100644
--- a/src/main/java/com/github/pedrovgs/problem12/MoveZerosInArray.java
+++ b/src/main/java/com/github/pedrovgs/problem12/MoveZerosInArray.java
@@ -39,7 +39,7 @@ public class MoveZerosInArray {
     while (swap) {
       swap = false;
       for (int i = 0; i < array.length - 1; i++) {
-        if ((array[i] < array[i + 1] && array[i + 1] > 0)) {
+        if (array[i] == 0 && array[i + 1] != 0) {
           swap(array, i, i + 1);
           swap = true;
         }
diff --git a/src/main/java/com/github/pedrovgs/problem13/BinaryTreeByLevel.java b/src/main/java/com/github/pedrovgs/problem13/BinaryTreeByLevel.java
index bf01de5..b0ef379 100644
--- a/src/main/java/com/github/pedrovgs/problem13/BinaryTreeByLevel.java
+++ b/src/main/java/com/github/pedrovgs/problem13/BinaryTreeByLevel.java
@@ -31,7 +31,7 @@ public class BinaryTreeByLevel {
 
   /**
    * Add implementation based on an additional data structure, one queue which implementation is a
-   * LinkedList. We we are going to do is add elements of the tree to the queue and one by one
+   * LinkedList. What we are going to do is add elements of the tree to the queue and one by one
    * evaluate it adding more binary nodes to the queue if exist. The complexity order in time terms
    * is O(N) where N is the number of elements in the tree. The complexity order in space terms is
    * O(N) where N is the number of elements in the tree because we are going to store every node in
diff --git a/src/main/java/com/github/pedrovgs/problem4/SquareRoot.java b/src/main/java/com/github/pedrovgs/problem4/SquareRoot.java
index 809da1e..aac4394 100644
--- a/src/main/java/com/github/pedrovgs/problem4/SquareRoot.java
+++ b/src/main/java/com/github/pedrovgs/problem4/SquareRoot.java
@@ -61,7 +61,7 @@ public class SquareRoot {
       if (result > number) {
         top -= 0.1f;
       } else {
-        bottom -= 0.1f;
+        bottom += 0.1f;
       }
       newCandidate = (top + bottom) / 2;
       result = newCandidate * newCandidate;
