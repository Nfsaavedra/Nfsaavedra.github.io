diff --git a/src/main/java/concurrency/ParallelDemo.java b/src/main/java/concurrency/ParallelDemo.java
index b204be7..7a791d6 100644
--- a/src/main/java/concurrency/ParallelDemo.java
+++ b/src/main/java/concurrency/ParallelDemo.java
@@ -29,17 +29,17 @@ public class ParallelDemo {
         System.out.println("Total = " + total);
 
         // Use Java 8 Streams
-//        total = 0; // local variable; not an attribute
+        total = 0; // local variable; not an attribute
 //        IntStream.of(3, 1, 4, 1, 5, 9)
 //                .forEach(n -> total += n); // not legal; total needs to be effectively final
 //        System.out.println("Total = " + total);
 
-        total = IntStream.of(3, 1, 4, 1, 5, 9)
+        total = IntStream.of(3, 1, 4, 1, 5, 9, 2, 6)
                 .sum();
         System.out.println("Total = " + total);
 
         Instant before = Instant.now();
-        total = IntStream.of(3, 1, 4, 1, 5, 9)
+        total = IntStream.of(3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 7, 9, 7)
                 .parallel()
                 .map(ParallelDemo::doubleIt)
                 .sum();
diff --git a/src/main/java/datetime/FunnyOffsets.java b/src/main/java/datetime/FunnyOffsets.java
index 93143c0..9dd54e2 100644
--- a/src/main/java/datetime/FunnyOffsets.java
+++ b/src/main/java/datetime/FunnyOffsets.java
@@ -22,6 +22,7 @@ public class FunnyOffsets {
     public static void main(String[] args) {
         Instant instant = Instant.now();
         ZonedDateTime current = instant.atZone(ZoneId.systemDefault());
+        // equivalent to ZonedDateTime.now()
         System.out.printf("Current time is %s%n%n", current);
 
         System.out.printf("%10s %20s %13s%n", "Offset", "ZoneId", "Time");
diff --git a/src/main/java/fileio/ProcessDictionary.java b/src/main/java/fileio/ProcessDictionary.java
index 698d6d5..c502c50 100644
--- a/src/main/java/fileio/ProcessDictionary.java
+++ b/src/main/java/fileio/ProcessDictionary.java
@@ -33,7 +33,7 @@ public class ProcessDictionary {
     }
 
     public void printWordsOfEachLength() {
-        System.out.println("\nNumber of words of each length:");
+        System.out.println("\nList of words of each length:");
         try (Stream<String> lines = Files.lines(dictionary)) {
             lines.filter(s -> s.length() > 20)
                     .collect(groupingBy(String::length)) // Map<Integer,List<String>>
@@ -47,7 +47,7 @@ public class ProcessDictionary {
         System.out.println("\nNumber of words of each length:");
         try (Stream<String> lines = Files.lines(dictionary)) {
             lines.filter(s -> s.length() > 20)
-                    .collect(Collectors.groupingBy(String::length, Collectors.counting()))
+                    .collect(Collectors.groupingBy(String::length, Collectors.counting())) // Map<Integer,Long>
                     .forEach((len, num) -> System.out.printf("%d: %d%n", len, num));
         } catch (IOException e) {
             e.printStackTrace();
diff --git a/src/main/java/streams/BoxedStreams.java b/src/main/java/streams/BoxedStreams.java
index abeef45..2efe6ba 100644
--- a/src/main/java/streams/BoxedStreams.java
+++ b/src/main/java/streams/BoxedStreams.java
@@ -9,7 +9,7 @@ public class BoxedStreams {
     public static void main(String[] args) {
 
         IntStream.rangeClosed(1, 10)
-                .mapToObj(Integer::new)
+                .mapToObj(Integer::valueOf)
                 .collect(Collectors.toList());
 
         List<Integer> ints = IntStream.of(3, 1, 4, 1, 5, 9)
diff --git a/src/main/java/streams/ReduceDemo.java b/src/main/java/streams/ReduceDemo.java
index 179c1d7..e18d579 100644
--- a/src/main/java/streams/ReduceDemo.java
+++ b/src/main/java/streams/ReduceDemo.java
@@ -23,12 +23,12 @@ public class ReduceDemo {
 
         sum = IntStream.rangeClosed(1, 10)
                 .reduce(Integer::sum).orElse(0);
-
-        sum = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
-                .reduce(0, Integer::sum);
-
-
-        // Off-by-one error: first value doesn't get doubled
+//
+//        sum = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
+//                .reduce(0, Integer::sum);
+//
+//
+//        // Off-by-one error: first value doesn't get doubled
         int doubleSum = IntStream.rangeClosed(1, 10)
                 .reduce((acc, n) -> acc + 2 * n).orElse(0);
         System.out.println(doubleSum);
@@ -55,51 +55,51 @@ public class ReduceDemo {
         Integer max = Stream.of(3, 1, 4, 1, 5, 9)
                 .reduce(Integer.MIN_VALUE, Integer::max);
         System.out.println("The max value is " + max);
-
-
-        /* String example */
-        // Inefficient, but works
-        String s = Stream.of("this", "is", "a", "list")
-                .reduce("", String::concat);
-        System.out.println(s);
-
-        // Better, but verbose
-        s = Stream.of("this", "is", "a", "list")
-                .collect(() -> new StringBuilder(),
-                        (sb, str) -> sb.append(str),
-                        (sb1, sb2) -> sb1.append(sb2))
-                .toString();
-
-        // Better and simpler
-        s = Stream.of("this", "is", "a", "list")
-                .collect(StringBuilder::new,
-                        StringBuilder::append,
-                        StringBuilder::append)
-                .toString();
-
-        // Best (or at least simplest)
-        s = Stream.of("this", "is", "a", "list")
-                .collect(Collectors.joining());
-
-
-        List<Book> books = Arrays.asList(
-                new Book(1, "Modern Java Recipes"),
-                new Book(2, "Making Java Groovy"),
-                new Book(3, "Gradle Recipes for Android"));
-
-        // Note: this is the HARD way; see AddCollectionToMap for easier ways
-        HashMap<Integer, Book> bookMap = books.stream()
-                .reduce(new HashMap<Integer, Book>(),  // identity for putAll
-                        (map, book) -> {               // add a single book to map
-                            map.put(book.getId(), book);
-                            return map;
-                        },
-                        (map1, map2) -> {              // join multiple maps
-                            map1.putAll(map2);
-                            return map1;
-                        });
-
-        bookMap.forEach((k,v) -> System.out.println(k + ": " + v));
-
+//
+//
+//        /* String example */
+//        // Inefficient, but works
+//        String s = Stream.of("this", "is", "a", "list")
+//                .reduce("", String::concat);
+//        System.out.println(s);
+//
+//        // Better, but verbose
+//        s = Stream.of("this", "is", "a", "list")
+//                .collect(() -> new StringBuilder(),
+//                        (sb, str) -> sb.append(str),
+//                        (sb1, sb2) -> sb1.append(sb2))
+//                .toString();
+//
+//        // Better and simpler
+//        s = Stream.of("this", "is", "a", "list")
+//                .collect(StringBuilder::new,
+//                        StringBuilder::append,
+//                        StringBuilder::append)
+//                .toString();
+//
+//        // Best (or at least simplest)
+//        s = Stream.of("this", "is", "a", "list")
+//                .collect(Collectors.joining());
+//
+//
+//        List<Book> books = Arrays.asList(
+//                new Book(1, "Modern Java Recipes"),
+//                new Book(2, "Making Java Groovy"),
+//                new Book(3, "Gradle Recipes for Android"));
+//
+//        // Note: this is the HARD way; see AddCollectionToMap for easier ways
+//        HashMap<Integer, Book> bookMap = books.stream()
+//                .reduce(new HashMap<Integer, Book>(),  // identity for putAll
+//                        (map, book) -> {               // add a single book to map
+//                            map.put(book.getId(), book);
+//                            return map;
+//                        },
+//                        (map1, map2) -> {              // join multiple maps
+//                            map1.putAll(map2);
+//                            return map1;
+//                        });
+//
+//        bookMap.forEach((k,v) -> System.out.println(k + ": " + v));
+//
     }
 }
