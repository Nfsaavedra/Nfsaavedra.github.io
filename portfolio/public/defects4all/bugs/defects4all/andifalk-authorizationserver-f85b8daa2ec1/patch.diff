diff --git a/.github/workflows/gradle.yml b/.github/workflows/gradle.yml
index 4f439b4..ef29434 100644
--- a/.github/workflows/gradle.yml
+++ b/.github/workflows/gradle.yml
@@ -16,7 +16,7 @@ jobs:
     strategy:
       matrix:
         # test against latest update of each major Java version, as well as specific updates of LTS versions:
-        java: [ 11, 11.0.3, 11.0.4, 11.0.5, 12, 13 ]
+        java: [ 11, 11.0.3, 11.0.4, 11.0.5, 14 ]
     steps:
     - uses: actions/checkout@v2
     - name: Set up JDK
diff --git a/build.gradle b/build.gradle
index 2f8131b..171f4a6 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,7 +1,9 @@
 plugins {
-    id 'org.springframework.boot' version '2.2.4.RELEASE'
+    id 'org.springframework.boot' version '2.2.6.RELEASE'
     id 'io.spring.dependency-management' version '1.0.9.RELEASE'
     id 'java'
+    id 'com.adarshr.test-logger' version '2.0.0'
+    id 'org.owasp.dependencycheck' version '5.3.2'
 }
 
 group = 'com.example'
@@ -26,7 +28,6 @@ dependencies {
     implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
     implementation 'org.springframework.boot:spring-boot-starter-web'
     implementation 'org.springframework.boot:spring-boot-starter-security'
-    //implementation 'org.springframework.boot:spring-boot-starter-oauth2-resource-server'
     implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
     implementation 'com.nimbusds:nimbus-jose-jwt:8.8'
     implementation 'org.apache.commons:commons-lang3:3.9'
@@ -45,3 +46,19 @@ dependencies {
 test {
     useJUnitPlatform()
 }
+
+dependencyCheck {
+    analyzedTypes = ['jar']
+    failBuildOnCVSS=8
+    format='ALL'
+    suppressionFile=file("$projectDir/dependency-check-suppressions.xml")
+    analyzers {
+        experimentalEnabled = false
+        assemblyEnabled = false
+        nuspecEnabled = false
+        nodeEnabled = false
+        nodeAuditEnabled = false
+        nexusEnabled = false
+    }
+}
+
diff --git a/dependency-check-suppressions.xml b/dependency-check-suppressions.xml
new file mode 100644
index 0000000..81e9211
--- /dev/null
+++ b/dependency-check-suppressions.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<suppressions xmlns="https://jeremylong.github.io/DependencyCheck/dependency-suppression.1.3.xsd">
+
+    <!-- Suppress false positives for spring security -->
+    <suppress>
+        <notes>Only vulnerable when used in combination with Spring 5.0.5, we use 5.3+</notes>
+        <packageUrl regex="true">^pkg:maven/org\.springframework\.security/spring\-security\-.*@.*$</packageUrl>
+        <cve>CVE-2018-1258</cve>
+    </suppress>
+    <suppress>
+        <notes>Spring Security RSA uses a different version than Spring Security</notes>
+        <packageUrl regex="true">^pkg:maven/org\.springframework\.security/spring\-security\-rsa@.*$</packageUrl>
+        <cpe>cpe:/a:pivotal:spring_security_oauth</cpe>
+    </suppress>
+    <suppress>
+        <notes>Spring Security RSA uses a different version than Spring Security</notes>
+        <packageUrl regex="true">^pkg:maven/org\.springframework\.security/spring\-security\-rsa@.*$</packageUrl>
+        <cpe>cpe:/a:pivotal_software:spring_security</cpe>
+    </suppress>
+    <suppress>
+        <notes>Spring Security RSA uses a different version than Spring Security</notes>
+        <packageUrl regex="true">^pkg:maven/org\.springframework\.security/spring\-security\-rsa@.*$</packageUrl>
+        <cpe>cpe:/a:vmware:springsource_spring_security</cpe>
+    </suppress>
+
+</suppressions>
diff --git a/src/main/java/com/example/authorizationserver/DataInitializer.java b/src/main/java/com/example/authorizationserver/DataInitializer.java
index a03e7e8..59d8f13 100644
--- a/src/main/java/com/example/authorizationserver/DataInitializer.java
+++ b/src/main/java/com/example/authorizationserver/DataInitializer.java
@@ -117,8 +117,8 @@ public class DataInitializer implements CommandLineRunner {
         Stream.of(
                 new RegisteredClient(
                     UUID.randomUUID(),
-                    "confidential-demo",
-                    "demo",
+                    "confidential-jwt",
+                    passwordEncoder.encode("demo"),
                     true,
                     AccessTokenFormat.JWT,
                     Set.of(GrantType.AUTHORIZATION_CODE, GrantType.CLIENT_CREDENTIALS),
@@ -127,8 +127,8 @@ public class DataInitializer implements CommandLineRunner {
                     Collections.singleton("*")),
                 new RegisteredClient(
                     UUID.randomUUID(),
-                    "public-demo",
-                    null,
+                    "public-jwt",
+                    passwordEncoder.encode("n/a"),
                     false,
                     AccessTokenFormat.JWT,
                     Set.of(GrantType.AUTHORIZATION_CODE),
@@ -137,13 +137,23 @@ public class DataInitializer implements CommandLineRunner {
                     Collections.singleton("*")),
                 new RegisteredClient(
                     UUID.randomUUID(),
-                    "opaque-demo",
-                    null,
-                    false,
+                    "confidential-opaque",
+                    passwordEncoder.encode("demo"),
+                    true,
                     AccessTokenFormat.OPAQUE,
                     Set.of(GrantType.AUTHORIZATION_CODE, GrantType.CLIENT_CREDENTIALS),
                     Collections.singleton(
                         "http://localhost:9090/demo-client/login/oauth2/code/demo"),
+                    Collections.singleton("*")),
+                new RegisteredClient(
+                    UUID.randomUUID(),
+                    "public-opaque",
+                    passwordEncoder.encode("n/a"),
+                    false,
+                    AccessTokenFormat.OPAQUE,
+                    Set.of(GrantType.AUTHORIZATION_CODE),
+                    Collections.singleton(
+                        "http://localhost:9090/demo-client/login/oauth2/code/demo"),
                     Collections.singleton("*")))
             .map(registeredClientRepository::save)
             .collect(Collectors.toSet());
diff --git a/src/main/java/com/example/authorizationserver/config/WebSecurityConfiguration.java b/src/main/java/com/example/authorizationserver/config/WebSecurityConfiguration.java
index cc5f886..8ffd9db 100644
--- a/src/main/java/com/example/authorizationserver/config/WebSecurityConfiguration.java
+++ b/src/main/java/com/example/authorizationserver/config/WebSecurityConfiguration.java
@@ -6,7 +6,6 @@ import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.beans.factory.annotation.Qualifier;
 import org.springframework.context.annotation.Configuration;
 import org.springframework.core.annotation.Order;
-import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
 import org.springframework.security.config.annotation.web.builders.HttpSecurity;
 import org.springframework.security.config.annotation.web.builders.WebSecurity;
 import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
@@ -29,6 +28,12 @@ public class WebSecurityConfiguration {
       this.registeredClientDetailsService = registeredClientDetailsService;
     }
 
+    @Override
+    public void configure(WebSecurity web) {
+      web.ignoring().mvcMatchers("/token", "/introspect",
+              "/revoke", "/userinfo", "/.well-known/openid-configuration", "/jwks");
+    }
+
     protected void configure(HttpSecurity http) throws Exception {
       http.requestMatchers(
               r ->
diff --git a/src/main/java/com/example/authorizationserver/oauth/endpoint/AuthorizationEndpoint.java b/src/main/java/com/example/authorizationserver/oauth/endpoint/AuthorizationEndpoint.java
index e93622e..5e12a49 100644
--- a/src/main/java/com/example/authorizationserver/oauth/endpoint/AuthorizationEndpoint.java
+++ b/src/main/java/com/example/authorizationserver/oauth/endpoint/AuthorizationEndpoint.java
@@ -10,6 +10,8 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.springframework.http.MediaType;
 import org.springframework.http.ResponseEntity;
+import org.springframework.security.access.prepost.PreAuthorize;
+import org.springframework.security.authentication.BadCredentialsException;
 import org.springframework.security.core.annotation.AuthenticationPrincipal;
 import org.springframework.stereotype.Controller;
 import org.springframework.validation.annotation.Validated;
@@ -166,6 +168,7 @@ public class AuthorizationEndpoint {
    * @return redirection to client with authorization code
    */
   @SuppressWarnings({"unused", "SpringMVCViewInspection"})
+  @PreAuthorize("isAuthenticated()")
   @GetMapping(ENDPOINT)
   public String authorizationRequest(
           @RequestParam("response_type") @Pattern(regexp = "code") String responseType,
@@ -201,6 +204,10 @@ public class AuthorizationEndpoint {
         redirectUri,
         endUserDetails != null ? endUserDetails.getUsername() : "n/a");
 
+    if (endUserDetails == null || endUserDetails.getIdentifier() == null) {
+      throw new BadCredentialsException("No user");
+    }
+
     if (StringUtils.isBlank(clientId)) {
       throw new InvalidClientIdError("");
     }
diff --git a/src/main/java/com/example/authorizationserver/oauth/endpoint/IntrospectionEndpoint.java b/src/main/java/com/example/authorizationserver/oauth/endpoint/IntrospectionEndpoint.java
index c0f0a59..6860464 100644
--- a/src/main/java/com/example/authorizationserver/oauth/endpoint/IntrospectionEndpoint.java
+++ b/src/main/java/com/example/authorizationserver/oauth/endpoint/IntrospectionEndpoint.java
@@ -22,6 +22,9 @@ import org.springframework.web.bind.annotation.RequestHeader;
 import org.springframework.web.bind.annotation.RestController;
 
 import java.text.ParseException;
+import java.time.ZoneId;
+import java.time.temporal.ChronoField;
+import java.time.temporal.TemporalField;
 import java.util.Optional;
 import java.util.UUID;
 
@@ -80,20 +83,34 @@ public class IntrospectionEndpoint {
     try {
       opaqueWebToken.validate();
       clientId = opaqueWebToken.getClientId();
-      user = userService.findOneByIdentifier(UUID.fromString(opaqueWebToken.getSubject()));
-      return user.map(
-              u -> {
-                IntrospectionResponse introspectionResponse = new IntrospectionResponse();
-                introspectionResponse.setActive(true);
-                introspectionResponse.setClient_id(clientId);
-                introspectionResponse.setSub(u.getIdentifier().toString());
-                introspectionResponse.setUsername(u.getUsername());
-                /*introspectionResponse.setIss(jwtClaimsSet.getIssuer());
-                introspectionResponse.setNbf(jwtClaimsSet.getNotBeforeTime().getTime());
-                introspectionResponse.setIat(jwtClaimsSet.getIssueTime().getTime());*/
-                return introspectionResponse;
-              })
-          .orElse(new IntrospectionResponse(false));
+      if (TokenService.ANONYMOUS_TOKEN.equals(opaqueWebToken.getSubject())) {
+        IntrospectionResponse introspectionResponse = new IntrospectionResponse();
+        introspectionResponse.setActive(true);
+        introspectionResponse.setClient_id(clientId);
+        introspectionResponse.setSub(TokenService.ANONYMOUS_TOKEN);
+        introspectionResponse.setUsername(TokenService.ANONYMOUS_TOKEN);
+        introspectionResponse.setExp(opaqueWebToken.getExpiry().atZone(ZoneId.systemDefault()).toEpochSecond());
+        introspectionResponse.setIss(opaqueWebToken.getIssuer());
+        introspectionResponse.setNbf(opaqueWebToken.getNotBefore().atZone(ZoneId.systemDefault()).toEpochSecond());
+        introspectionResponse.setIat(opaqueWebToken.getIssuedAt().atZone(ZoneId.systemDefault()).toEpochSecond());
+        return introspectionResponse;
+      } else {
+        user = userService.findOneByIdentifier(UUID.fromString(opaqueWebToken.getSubject()));
+        return user.map(
+                u -> {
+                  IntrospectionResponse introspectionResponse = new IntrospectionResponse();
+                  introspectionResponse.setActive(true);
+                  introspectionResponse.setClient_id(clientId);
+                  introspectionResponse.setSub(u.getIdentifier().toString());
+                  introspectionResponse.setUsername(u.getUsername());
+                  introspectionResponse.setExp(opaqueWebToken.getExpiry().atZone(ZoneId.systemDefault()).toEpochSecond());
+                  introspectionResponse.setIss(opaqueWebToken.getIssuer());
+                  introspectionResponse.setNbf(opaqueWebToken.getNotBefore().atZone(ZoneId.systemDefault()).toEpochSecond());
+                  introspectionResponse.setIat(opaqueWebToken.getIssuedAt().atZone(ZoneId.systemDefault()).toEpochSecond());
+                  return introspectionResponse;
+                })
+            .orElse(new IntrospectionResponse(false));
+      }
     } catch (BadCredentialsException ex) {
       return new IntrospectionResponse(false);
     }
diff --git a/src/main/java/com/example/authorizationserver/oauth/endpoint/TokenEndpoint.java b/src/main/java/com/example/authorizationserver/oauth/endpoint/TokenEndpoint.java
index 4265679..450b227 100644
--- a/src/main/java/com/example/authorizationserver/oauth/endpoint/TokenEndpoint.java
+++ b/src/main/java/com/example/authorizationserver/oauth/endpoint/TokenEndpoint.java
@@ -23,6 +23,7 @@ import org.springframework.beans.factory.annotation.Value;
 import org.springframework.http.HttpStatus;
 import org.springframework.http.ResponseEntity;
 import org.springframework.security.authentication.BadCredentialsException;
+import org.springframework.security.crypto.password.PasswordEncoder;
 import org.springframework.web.bind.MissingServletRequestParameterException;
 import org.springframework.web.bind.annotation.ExceptionHandler;
 import org.springframework.web.bind.annotation.ModelAttribute;
@@ -31,7 +32,6 @@ import org.springframework.web.bind.annotation.RequestHeader;
 import org.springframework.web.bind.annotation.RequestMapping;
 import org.springframework.web.bind.annotation.RestController;
 
-import java.nio.charset.StandardCharsets;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.time.Duration;
@@ -39,6 +39,8 @@ import java.util.Base64;
 import java.util.Optional;
 import java.util.UUID;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+
 @RequestMapping(TokenEndpoint.ENDPOINT)
 @RestController
 public class TokenEndpoint {
@@ -50,20 +52,21 @@ public class TokenEndpoint {
   private final RegisteredClientService registeredClientService;
   private final UserService userService;
   private final TokenService tokenService;
+  private final PasswordEncoder passwordEncoder;
 
   private final Duration accessTokenLifetime;
   private final Duration idTokenLifetime;
   private final Duration refreshTokenLifetime;
 
   public TokenEndpoint(
-      AuthenticationService authenticationService,
-      AuthorizationCodeService authorizationCodeService,
-      UserService userService,
-      TokenService tokenService,
-      @Value("${auth-server.access-token.lifetime}") Duration accessTokenLifetime,
-      @Value("${auth-server.id-token.lifetime}") Duration idTokenLifetime,
-      @Value("${auth-server.refresh-token.lifetime}") Duration refreshTokenLifetime,
-      RegisteredClientService registeredClientService) {
+          AuthenticationService authenticationService,
+          AuthorizationCodeService authorizationCodeService,
+          UserService userService,
+          TokenService tokenService,
+          @Value("${auth-server.access-token.lifetime}") Duration accessTokenLifetime,
+          @Value("${auth-server.id-token.lifetime}") Duration idTokenLifetime,
+          @Value("${auth-server.refresh-token.lifetime}") Duration refreshTokenLifetime,
+          RegisteredClientService registeredClientService, PasswordEncoder passwordEncoder) {
     this.authenticationService = authenticationService;
     this.authorizationCodeService = authorizationCodeService;
     this.userService = userService;
@@ -72,6 +75,7 @@ public class TokenEndpoint {
     this.idTokenLifetime = idTokenLifetime;
     this.refreshTokenLifetime = refreshTokenLifetime;
     this.registeredClientService = registeredClientService;
+    this.passwordEncoder = passwordEncoder;
   }
 
   @PostMapping
@@ -98,48 +102,51 @@ public class TokenEndpoint {
   }
 
   /* ---------------------
-   Access Token Request
+  Access Token Request
 
-   The client makes a request to the token endpoint by sending the
-   following parameters using the "application/x-www-form-urlencoded"
-   format per Appendix B with a character encoding of UTF-8 in the HTTP
-   request entity-body:
+  The client makes a request to the token endpoint by sending the
+  following parameters using the "application/x-www-form-urlencoded"
+  format per Appendix B with a character encoding of UTF-8 in the HTTP
+  request entity-body:
 
-   grant_type
-         REQUIRED.  Value MUST be set to "authorization_code".
+  grant_type
+        REQUIRED.  Value MUST be set to "authorization_code".
 
-   code
-         REQUIRED.  The authorization code received from the
-         authorization server.
+  code
+        REQUIRED.  The authorization code received from the
+        authorization server.
 
-   redirect_uri
-         REQUIRED, if the "redirect_uri" parameter was included in the
-         authorization request as described in Section 4.1.1, and their
-         values MUST be identical.
+  redirect_uri
+        REQUIRED, if the "redirect_uri" parameter was included in the
+        authorization request as described in Section 4.1.1, and their
+        values MUST be identical.
 
-   client_id
-         REQUIRED, if the client is not authenticating with the
-         authorization server as described in Section 3.2.1.
+  client_id
+        REQUIRED, if the client is not authenticating with the
+        authorization server as described in Section 3.2.1.
 
-   If the client type is confidential or the client was issued client
-   credentials (or assigned other authentication requirements), the
-   client MUST authenticate with the authorization server.
-   */
+  If the client type is confidential or the client was issued client
+  credentials (or assigned other authentication requirements), the
+  client MUST authenticate with the authorization server.
+  */
   private ResponseEntity<TokenResponse> getTokenResponseForAuthorizationCode(
       String authorizationHeader, TokenRequest tokenRequest) throws JOSEException {
 
-    ClientCredentials clientCredentials = retrieveClientCredentials(authorizationHeader, tokenRequest);
+    ClientCredentials clientCredentials =
+        retrieveClientCredentials(authorizationHeader, tokenRequest);
 
     if (clientCredentials == null) {
       return reportInvalidClientError();
     }
 
     AuthorizationCode authorizationCode = authorizationCodeService.getCode(tokenRequest.getCode());
-    if (authorizationCode == null || !clientCredentials.getClientId().equals(authorizationCode.getClientId())) {
+    if (authorizationCode == null
+        || !clientCredentials.getClientId().equals(authorizationCode.getClientId())) {
       return reportInvalidClientError();
     }
 
-    RegisteredClient registeredClient = registeredClientService.findOneByClientId(clientCredentials.getClientId());
+    RegisteredClient registeredClient =
+        registeredClientService.findOneByClientId(clientCredentials.getClientId());
 
     if (!registeredClient.getGrantTypes().contains(GrantType.AUTHORIZATION_CODE)) {
       return reportInvalidGrantError();
@@ -147,7 +154,7 @@ public class TokenEndpoint {
 
     if (registeredClient.isConfidential()) {
       if (StringUtils.isBlank(clientCredentials.getClientSecret())
-          || !registeredClient.getClientSecret().equals(clientCredentials.getClientSecret())) {
+          || !passwordEncoder.matches(clientCredentials.getClientSecret(), registeredClient.getClientSecret())) {
         return reportInvalidClientError();
       }
     } else {
@@ -157,7 +164,8 @@ public class TokenEndpoint {
           // Rehash the code verifier
           try {
             String rehashedChallenge = rehashCodeVerifier(tokenRequest.getCode_verifier());
-            if (!authorizationCode.getCode_challenge().equals(rehashedChallenge)) {
+            if (!MessageDigest.isEqual(
+                authorizationCode.getCode_challenge().getBytes(UTF_8), rehashedChallenge.getBytes(UTF_8))) {
               return reportInvalidGrantError();
             }
           } catch (NoSuchAlgorithmException e) {
@@ -215,44 +223,51 @@ public class TokenEndpoint {
   }
 
   /* -------------------
-   Access Token Request
+  Access Token Request
 
-   The client makes a request to the token endpoint by adding the
-   following parameters using the "application/x-www-form-urlencoded"
-   format per Appendix B with a character encoding of UTF-8 in the HTTP
-   request entity-body:
+  The client makes a request to the token endpoint by adding the
+  following parameters using the "application/x-www-form-urlencoded"
+  format per Appendix B with a character encoding of UTF-8 in the HTTP
+  request entity-body:
 
-   grant_type
-         REQUIRED.  Value MUST be set to "client_credentials".
+  grant_type
+        REQUIRED.  Value MUST be set to "client_credentials".
 
-   scope
-         OPTIONAL.  The scope of the access request as described by
-         Section 3.3.
+  scope
+        OPTIONAL.  The scope of the access request as described by
+        Section 3.3.
 
-   The client MUST authenticate with the authorization server
-   */
+  The client MUST authenticate with the authorization server
+  */
   private ResponseEntity<TokenResponse> getTokenResponseForClientCredentials(
       String authorizationHeader, TokenRequest tokenRequest) throws JOSEException {
 
-    ClientCredentials clientCredentials = retrieveClientCredentials(authorizationHeader, tokenRequest);
+    ClientCredentials clientCredentials =
+        retrieveClientCredentials(authorizationHeader, tokenRequest);
 
     if (clientCredentials == null) {
       return reportInvalidClientError();
     }
 
-    RegisteredClient registeredClient = registeredClientService.findOneByClientId(clientCredentials.getClientId());
-    if (registeredClient != null && registeredClient.getClientSecret().equals(clientCredentials.getClientSecret())) {
+    RegisteredClient registeredClient =
+        registeredClientService.findOneByClientId(clientCredentials.getClientId());
+    if (registeredClient != null
+        && passwordEncoder.matches(clientCredentials.getClientSecret(), registeredClient.getClientSecret())) {
       if (registeredClient.getGrantTypes().contains(GrantType.CLIENT_CREDENTIALS)) {
         return ResponseEntity.ok(
             new TokenResponse(
                 AccessTokenFormat.JWT.equals(registeredClient.getAccessTokenFormat())
                     ? tokenService
-                        .createAnonymousJwtAccessToken(clientCredentials.getClientId(), accessTokenLifetime)
+                        .createAnonymousJwtAccessToken(
+                            clientCredentials.getClientId(), accessTokenLifetime)
                         .getValue()
                     : tokenService
-                        .createAnonymousOpaqueAccessToken(clientCredentials.getClientId(), accessTokenLifetime)
+                        .createAnonymousOpaqueAccessToken(
+                            clientCredentials.getClientId(), accessTokenLifetime)
                         .getValue(),
-                tokenService.createRefreshToken(clientCredentials.getClientId(), refreshTokenLifetime).getValue(),
+                tokenService
+                    .createRefreshToken(clientCredentials.getClientId(), refreshTokenLifetime)
+                    .getValue(),
                 accessTokenLifetime.toSeconds(),
                 null));
       } else {
@@ -264,41 +279,44 @@ public class TokenEndpoint {
   }
 
   /* ------------------
-   Access Token Request
+  Access Token Request
 
-   The client makes a request to the token endpoint by adding the
-   following parameters using the "application/x-www-form-urlencoded"
-   format per Appendix B with a character encoding of UTF-8 in the HTTP
-   request entity-body:
+  The client makes a request to the token endpoint by adding the
+  following parameters using the "application/x-www-form-urlencoded"
+  format per Appendix B with a character encoding of UTF-8 in the HTTP
+  request entity-body:
 
-   grant_type
-         REQUIRED.  Value MUST be set to "password".
+  grant_type
+        REQUIRED.  Value MUST be set to "password".
 
-   username
-         REQUIRED.  The resource owner username.
+  username
+        REQUIRED.  The resource owner username.
 
-   password
-         REQUIRED.  The resource owner password.
+  password
+        REQUIRED.  The resource owner password.
 
-   scope
-         OPTIONAL.  The scope of the access request as described by
-         Section 3.3.
+  scope
+        OPTIONAL.  The scope of the access request as described by
+        Section 3.3.
 
-   If the client type is confidential or the client was issued client
-   credentials (or assigned other authentication requirements), the
-   client MUST authenticate with the authorization server
-   */
+  If the client type is confidential or the client was issued client
+  credentials (or assigned other authentication requirements), the
+  client MUST authenticate with the authorization server
+  */
   private ResponseEntity<TokenResponse> getTokenResponseForPassword(
       String authorizationHeader, TokenRequest tokenRequest) throws JOSEException {
 
-    ClientCredentials clientCredentials = retrieveClientCredentials(authorizationHeader, tokenRequest);
+    ClientCredentials clientCredentials =
+        retrieveClientCredentials(authorizationHeader, tokenRequest);
 
     if (clientCredentials == null) {
       return reportInvalidClientError();
     }
 
-    RegisteredClient registeredClient = registeredClientService.findOneByClientId(clientCredentials.getClientId());
-    if (registeredClient != null && registeredClient.getClientSecret().equals(clientCredentials.getClientSecret())) {
+    RegisteredClient registeredClient =
+        registeredClientService.findOneByClientId(clientCredentials.getClientId());
+    if (registeredClient != null
+        && registeredClient.getClientSecret().equals(clientCredentials.getClientSecret())) {
       if (registeredClient.getGrantTypes().contains(GrantType.PASSWORD)) {
 
         User authenticatedUser;
@@ -315,13 +333,18 @@ public class TokenEndpoint {
                 AccessTokenFormat.JWT.equals(registeredClient.getAccessTokenFormat())
                     ? tokenService
                         .createPersonalizedJwtAccessToken(
-                            authenticatedUser, clientCredentials.getClientId(), null, accessTokenLifetime)
+                            authenticatedUser,
+                            clientCredentials.getClientId(),
+                            null,
+                            accessTokenLifetime)
                         .getValue()
                     : tokenService
                         .createPersonalizedOpaqueAccessToken(
                             authenticatedUser, clientCredentials.getClientId(), accessTokenLifetime)
                         .getValue(),
-                tokenService.createRefreshToken(clientCredentials.getClientId(), refreshTokenLifetime).getValue(),
+                tokenService
+                    .createRefreshToken(clientCredentials.getClientId(), refreshTokenLifetime)
+                    .getValue(),
                 accessTokenLifetime.toSeconds(),
                 null));
       } else {
@@ -333,52 +356,64 @@ public class TokenEndpoint {
   }
 
   /* -------------------------
-   Refreshing an Access Token
-
-   If the authorization server issued a refresh token to the client, the
-   client makes a refresh request to the token endpoint by adding the
-   following parameters using the "application/x-www-form-urlencoded"
-   format per Appendix B with a character encoding of UTF-8 in the HTTP
-   request entity-body:
-
-   grant_type
-         REQUIRED.  Value MUST be set to "refresh_token".
-   refresh_token
-         REQUIRED.  The refresh token issued to the client.
-   scope
-         OPTIONAL.  The scope of the access request as described by
-         Section 3.3.  The requested scope MUST NOT include any scope
-         not originally granted by the resource owner, and if omitted is
-         treated as equal to the scope originally granted by the
-         resource owner.
-   */
+  Refreshing an Access Token
+
+  If the authorization server issued a refresh token to the client, the
+  client makes a refresh request to the token endpoint by adding the
+  following parameters using the "application/x-www-form-urlencoded"
+  format per Appendix B with a character encoding of UTF-8 in the HTTP
+  request entity-body:
+
+  grant_type
+        REQUIRED.  Value MUST be set to "refresh_token".
+  refresh_token
+        REQUIRED.  The refresh token issued to the client.
+  scope
+        OPTIONAL.  The scope of the access request as described by
+        Section 3.3.  The requested scope MUST NOT include any scope
+        not originally granted by the resource owner, and if omitted is
+        treated as equal to the scope originally granted by the
+        resource owner.
+  */
   private ResponseEntity<TokenResponse> getTokenResponseForRefreshToken(
-          String authorizationHeader, TokenRequest tokenRequest) throws JOSEException {
+      String authorizationHeader, TokenRequest tokenRequest) throws JOSEException {
 
-    ClientCredentials clientCredentials = retrieveClientCredentials(authorizationHeader, tokenRequest);
+    ClientCredentials clientCredentials =
+        retrieveClientCredentials(authorizationHeader, tokenRequest);
 
     if (clientCredentials == null) {
       return reportInvalidClientError();
     }
 
-    RegisteredClient registeredClient = registeredClientService.findOneByClientId(clientCredentials.getClientId());
-    if (registeredClient != null && registeredClient.getClientSecret().equals(clientCredentials.getClientSecret())) {
+    RegisteredClient registeredClient =
+        registeredClientService.findOneByClientId(clientCredentials.getClientId());
+    if (registeredClient != null
+        && registeredClient.getClientSecret().equals(clientCredentials.getClientSecret())) {
       if (registeredClient.getGrantTypes().contains(GrantType.REFRESH_TOKEN)) {
-        OpaqueToken opaqueWebToken = tokenService.findOpaqueWebToken(tokenRequest.getRefresh_token());
+        OpaqueToken opaqueWebToken =
+            tokenService.findOpaqueWebToken(tokenRequest.getRefresh_token());
         if (opaqueWebToken != null && opaqueWebToken.isRefreshToken()) {
-          Optional<User> authenticatedUser = userService.findOneByIdentifier(UUID.fromString(opaqueWebToken.getSubject()));
+          Optional<User> authenticatedUser =
+              userService.findOneByIdentifier(UUID.fromString(opaqueWebToken.getSubject()));
           if (authenticatedUser.isPresent()) {
-            //TODO: Remove refresh token
+            // TODO: Remove refresh token
             return ResponseEntity.ok(
                 new TokenResponse(
                     AccessTokenFormat.JWT.equals(registeredClient.getAccessTokenFormat())
                         ? tokenService
-                            .createPersonalizedJwtAccessToken(authenticatedUser.get(), clientCredentials.getClientId(), null, accessTokenLifetime)
+                            .createPersonalizedJwtAccessToken(
+                                authenticatedUser.get(),
+                                clientCredentials.getClientId(),
+                                null,
+                                accessTokenLifetime)
                             .getValue()
                         : tokenService
-                            .createAnonymousOpaqueAccessToken(clientCredentials.getClientId(), accessTokenLifetime)
+                            .createAnonymousOpaqueAccessToken(
+                                clientCredentials.getClientId(), accessTokenLifetime)
                             .getValue(),
-                    tokenService.createRefreshToken(clientCredentials.getClientId(), refreshTokenLifetime).getValue(),
+                    tokenService
+                        .createRefreshToken(clientCredentials.getClientId(), refreshTokenLifetime)
+                        .getValue(),
                     accessTokenLifetime.toSeconds(),
                     null));
           }
@@ -392,13 +427,14 @@ public class TokenEndpoint {
     }
   }
 
-  private ClientCredentials retrieveClientCredentials(String authorizationHeader, TokenRequest tokenRequest) {
+  private ClientCredentials retrieveClientCredentials(
+      String authorizationHeader, TokenRequest tokenRequest) {
     ClientCredentials clientCredentials = null;
     if (authorizationHeader != null) {
-      clientCredentials =
-              AuthenticationUtil.fromBasicAuthHeader(authorizationHeader);
+      clientCredentials = AuthenticationUtil.fromBasicAuthHeader(authorizationHeader);
     } else if (StringUtils.isNotBlank(tokenRequest.getClient_id())) {
-      clientCredentials = new ClientCredentials(tokenRequest.getClient_id(), tokenRequest.getClient_secret());
+      clientCredentials =
+          new ClientCredentials(tokenRequest.getClient_id(), tokenRequest.getClient_secret());
     }
     return clientCredentials;
   }
@@ -409,7 +445,7 @@ public class TokenEndpoint {
 
   private String rehashCodeVerifier(String codeVerifier) throws NoSuchAlgorithmException {
     final MessageDigest digest = MessageDigest.getInstance("SHA-256");
-    final byte[] hashedBytes = digest.digest(codeVerifier.getBytes(StandardCharsets.UTF_8));
+    final byte[] hashedBytes = digest.digest(codeVerifier.getBytes(UTF_8));
     return Base64.getUrlEncoder().withoutPadding().encodeToString(hashedBytes);
   }
 
diff --git a/src/main/java/com/example/authorizationserver/token/store/TokenService.java b/src/main/java/com/example/authorizationserver/token/store/TokenService.java
index 29e7428..aaa7ffe 100644
--- a/src/main/java/com/example/authorizationserver/token/store/TokenService.java
+++ b/src/main/java/com/example/authorizationserver/token/store/TokenService.java
@@ -8,6 +8,7 @@ import com.example.authorizationserver.token.store.model.JsonWebToken;
 import com.example.authorizationserver.token.store.model.OpaqueToken;
 import com.example.authorizationserver.user.model.User;
 import com.nimbusds.jose.JOSEException;
+import org.springframework.beans.factory.annotation.Value;
 import org.springframework.stereotype.Service;
 import org.springframework.transaction.annotation.Transactional;
 
@@ -20,6 +21,10 @@ import java.util.List;
 @Transactional(readOnly = true)
 public class TokenService {
 
+  public static final String ANONYMOUS_TOKEN = "anonymous";
+
+  private @Value("${auth-server.issuer}") String issuer;
+
   private final JsonWebTokenRepository jsonWebTokenRepository;
   private final OpaqueTokenRepository opaqueTokenRepository;
   private final JsonWebTokenService jsonWebTokenService;
@@ -103,12 +108,16 @@ public class TokenService {
   @Transactional
   public OpaqueToken createPersonalizedOpaqueAccessToken(
       User user, String clientId, Duration accessTokenLifetime) {
-    LocalDateTime expiryDateTime = LocalDateTime.now().plusMinutes(accessTokenLifetime.toMinutes());
+    LocalDateTime issueTime = LocalDateTime.now();
+    LocalDateTime expiryDateTime = issueTime.plusMinutes(accessTokenLifetime.toMinutes());
     String token = opaqueTokenService.createToken();
     OpaqueToken opaqueToken = new OpaqueToken();
     opaqueToken.setExpiry(expiryDateTime);
     opaqueToken.setValue(token);
     opaqueToken.setClientId(clientId);
+    opaqueToken.setIssuedAt(issueTime);
+    opaqueToken.setNotBefore(issueTime);
+    opaqueToken.setIssuer(issuer);
     opaqueToken.setSubject(user.getIdentifier().toString());
     return opaqueTokenRepository.save(opaqueToken);
   }
@@ -116,10 +125,14 @@ public class TokenService {
   @Transactional
   public OpaqueToken createAnonymousOpaqueAccessToken(
       String clientId, Duration accessTokenLifetime) {
-    LocalDateTime expiryDateTime = LocalDateTime.now().plusMinutes(accessTokenLifetime.toMinutes());
+    LocalDateTime issueTime = LocalDateTime.now();
+    LocalDateTime expiryDateTime = issueTime.plusMinutes(accessTokenLifetime.toMinutes());
     String token = opaqueTokenService.createToken();
     OpaqueToken opaqueToken = new OpaqueToken();
     opaqueToken.setExpiry(expiryDateTime);
+    opaqueToken.setIssuedAt(issueTime);
+    opaqueToken.setNotBefore(issueTime);
+    opaqueToken.setIssuer(issuer);
     opaqueToken.setValue(token);
     opaqueToken.setClientId(clientId);
     opaqueToken.setSubject("anonymous");
@@ -128,11 +141,14 @@ public class TokenService {
 
   @Transactional
   public OpaqueToken createRefreshToken(String clientId, Duration refreshTokenLifetime) {
-    LocalDateTime expiryDateTime =
-        LocalDateTime.now().plusMinutes(refreshTokenLifetime.toMinutes());
+    LocalDateTime issueTime = LocalDateTime.now();
+    LocalDateTime expiryDateTime = issueTime.plusMinutes(refreshTokenLifetime.toMinutes());
     String token = opaqueTokenService.createToken();
     OpaqueToken opaqueToken = new OpaqueToken();
     opaqueToken.setExpiry(expiryDateTime);
+    opaqueToken.setIssuedAt(issueTime);
+    opaqueToken.setNotBefore(issueTime);
+    opaqueToken.setIssuer(issuer);
     opaqueToken.setValue(token);
     opaqueToken.setRefreshToken(true);
     opaqueToken.setClientId(clientId);
diff --git a/src/main/java/com/example/authorizationserver/token/store/model/OpaqueToken.java b/src/main/java/com/example/authorizationserver/token/store/model/OpaqueToken.java
index 10f87f6..e6eb9eb 100644
--- a/src/main/java/com/example/authorizationserver/token/store/model/OpaqueToken.java
+++ b/src/main/java/com/example/authorizationserver/token/store/model/OpaqueToken.java
@@ -5,6 +5,7 @@ import org.springframework.security.authentication.BadCredentialsException;
 import javax.persistence.DiscriminatorValue;
 import javax.persistence.Entity;
 import javax.validation.constraints.NotBlank;
+import javax.validation.constraints.NotNull;
 import javax.validation.constraints.Size;
 import java.time.LocalDateTime;
 
@@ -20,6 +21,16 @@ public class OpaqueToken extends Token {
   @Size(max = 200)
   private String clientId;
 
+  @NotBlank
+  @Size(max = 200)
+  private String issuer;
+
+  @NotNull
+  private LocalDateTime issuedAt;
+
+  @NotNull
+  private LocalDateTime notBefore;
+
   public String getSubject() {
     return subject;
   }
@@ -36,6 +47,30 @@ public class OpaqueToken extends Token {
     this.clientId = clientId;
   }
 
+  public String getIssuer() {
+    return issuer;
+  }
+
+  public void setIssuer(String issuer) {
+    this.issuer = issuer;
+  }
+
+  public LocalDateTime getIssuedAt() {
+    return issuedAt;
+  }
+
+  public void setIssuedAt(LocalDateTime issuedAt) {
+    this.issuedAt = issuedAt;
+  }
+
+  public LocalDateTime getNotBefore() {
+    return notBefore;
+  }
+
+  public void setNotBefore(LocalDateTime notBefore) {
+    this.notBefore = notBefore;
+  }
+
   @Override
   public boolean isReferenceToken() {
     return true;
@@ -45,5 +80,8 @@ public class OpaqueToken extends Token {
     if (LocalDateTime.now().isAfter(this.getExpiry())) {
       throw new BadCredentialsException("Expired");
     }
+    if (LocalDateTime.now().isBefore(this.getNotBefore())) {
+      throw new BadCredentialsException("Not yet valid");
+    }
   }
 }
diff --git a/src/main/resources/application.yml b/src/main/resources/application.yml
index 1177dd0..fc56aeb 100644
--- a/src/main/resources/application.yml
+++ b/src/main/resources/application.yml
@@ -29,4 +29,4 @@ logging:
         authorizationserver: trace
     org:
       springframework:
-        security: info
+        security: debug
\ No newline at end of file
