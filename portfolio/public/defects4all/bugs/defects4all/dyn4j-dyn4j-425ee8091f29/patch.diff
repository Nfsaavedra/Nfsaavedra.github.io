diff --git a/src/main/java/org/dyn4j/collision/narrowphase/ExpandingSimplex.java b/src/main/java/org/dyn4j/collision/narrowphase/ExpandingSimplex.java
index 481a251..9e9b87a 100644
--- a/src/main/java/org/dyn4j/collision/narrowphase/ExpandingSimplex.java
+++ b/src/main/java/org/dyn4j/collision/narrowphase/ExpandingSimplex.java
@@ -147,4 +147,22 @@ final class ExpandingSimplex {
 	public final int size() {
 		return this.queue.size();
 	}
+	
+	/* (non-Javadoc)
+	 * @see java.lang.Object#toString()
+	 */
+	public String toString() {
+		StringBuilder sb = new StringBuilder();
+		sb.append("[");
+		int i = 0;
+		for (ExpandingSimplexEdge edge : this.queue) {
+			if (i != 0) sb.append(",");
+			sb.append(edge.point1)
+			  .append("=")
+			  .append(edge.distance);
+			i++;
+		}
+		sb.append("]");
+		return sb.toString();
+	}
 }
diff --git a/src/main/java/org/dyn4j/collision/narrowphase/LinkPostProcessor.java b/src/main/java/org/dyn4j/collision/narrowphase/LinkPostProcessor.java
index 30e0cd5..fad615c 100644
--- a/src/main/java/org/dyn4j/collision/narrowphase/LinkPostProcessor.java
+++ b/src/main/java/org/dyn4j/collision/narrowphase/LinkPostProcessor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2020 William Bittle  http://www.dyn4j.org/
+ * Copyright (c) 2010-2021 William Bittle  http://www.dyn4j.org/
  * All rights reserved.
  * 
  * Redistribution and use in source and binary forms, with or without modification, are permitted 
@@ -32,8 +32,11 @@ import org.dyn4j.geometry.Vector2;
 /**
  * A {@link NarrowphasePostProcessor} specifically for the {@link Link} class to solve the 
  * internal edge problem when using a chain of segments.
- * @author Willima Bittle
- * @version 3.2.2
+ * <p>
+ * NOTE: the {@link Link} class assumes one-way intersection as the right-handed normal of the
+ * edge. 
+ * @author William Bittle
+ * @version 4.2.0
  * @since 3.2.2
  * @see <a href="https://bullet.googlecode.com/files/GDC10_Coumans_Erwin_Contact.pdf">Slides 46-54</a>
  */
@@ -44,12 +47,12 @@ public final class LinkPostProcessor implements NarrowphasePostProcessor {
 	@Override
 	public void process(Convex convex1, Transform transform1, Convex convex2, Transform transform2, Penetration penetration) {
 		if (convex1 instanceof Link) {
-			process((Link)convex1, transform1, convex2, transform2, penetration);
+			process((Link)convex1, penetration);
 		} else if (convex2 instanceof Link) {
 			// for this case we convert the parameters to match the order specified
 			// by the other method and negate the incoming and outgoing normal to match
 			penetration.normal.negate();
-			process((Link)convex2, transform2, convex1, transform1, penetration);
+			process((Link)convex2, penetration);
 			penetration.normal.negate();
 		}
 	}
@@ -59,277 +62,94 @@ public final class LinkPostProcessor implements NarrowphasePostProcessor {
 	 * If not, the normal is modified to within the valid range of normals based on the connectivity and the collision
 	 * depth is adjusted.
 	 * @param link the link
-	 * @param transform1 the link's transform
-	 * @param convex the other convex
-	 * @param transform2 the other convex transform
 	 * @param penetration the narrow-phase collision information
 	 */
-	public void process(Link link, Transform transform1, Convex convex, Transform transform2, Penetration penetration) {
-		Vector2 n = penetration.getNormal();
-		Vector2 c = transform2.getTransformed(convex.getCenter());
+	public void process(Link link, Penetration penetration) {
+		Link prev = link.getPrevious();
+		Link next = link.getNext();
 		
-		Vector2 p1 = transform1.getTransformed(link.getPoint1());
-		Vector2 p2 = transform1.getTransformed(link.getPoint2());
-		Vector2 p0 = link.getPoint0() != null ? transform1.getTransformed(link.getPoint0()) : null;
-		Vector2 p3 = link.getPoint3() != null ? transform1.getTransformed(link.getPoint3()) : null;
-		
-		boolean convex1 = false;
-		boolean convex2 = false;
-		
-		// segments
-		Vector2 edge0 = null;
-		Vector2 edge1 = null;
-		Vector2 edge2 = null;
-		// segment normals
-		Vector2 normal0 = null;
-		Vector2 normal1 = null;
-		Vector2 normal2 = null;
-		
-		// the valid normal range
-		Vector2 normal = null;
-		Vector2 upper = null;
-		Vector2 lower = null;
-		
-		// where is the center of the other shape
-		// relative to the previous, next, and this
-		// segment?
-		// - = right side
-		// + = left side
-		double offset0 = 0;
-		double offset1 = 0;
-		double offset2 = 0;
+		if (prev == null && next == null) {
+			// if there's no connectivity info, then take
+			// what the narrowphase gave us
+			return;
+		}
 		
-		edge1 = p1.to(p2);
-		edge1.normalize();
-		normal1 = edge1.getLeftHandOrthogonalVector();
-		offset1 = normal1.dot(p1.to(c));
+		Vector2 normal = penetration.getNormal().copy();
+		Vector2 edge = link.getEdgeVector();
+		Vector2 edgeNormal = edge.getLeftHandOrthogonalVector();
 		
-		if (p0 != null) {
-			edge0 = p0.to(p1);
-			edge0.normalize();
-			// get the normal for p0->p1
-			normal0 = edge0.getLeftHandOrthogonalVector();
-			// does p0->p1->p2 make a convex feature?
-			convex1 = edge0.cross(edge1) >= 0;
-			// where is the center of the other shape
-			offset0 = normal0.dot(p0.to(c));
-		}
+		// what "side" is the normal pointing towards?
+		double side = normal.dot(edge);
 		
-		if (p3 != null) {
-			edge2 = p2.to(p3);
-			edge2.normalize();
-			// get the normal for p2->p3
-			normal2 = edge2.getLeftHandOrthogonalVector();
-			// does p1->p2->p3 make a convex feature?
-			convex2 = edge1.cross(edge2) >= 0;
-			// where is the center of the other shape
-			offset2 = normal2.dot(p2.to(c));
-		}
+		// check if the normal is pointing behind the edge normal
+		double back = normal.dot(edgeNormal);
 		
-		// do we have both previous and next vertices?
-		if (p0 != null && p3 != null) {
-			// are both features convex?
-			if (convex1 && convex2) {
-				//   O----O
-				//  /      \
-				// O        O
-				// is the center of the other shape on the convex side or the concave side?
-				boolean front = offset0 >= 0 || offset1 >= 0 || offset2 >= 0;
-				if (front) {
-					// its on the outside (convex), so the normal has be between the
-					// normal of p0->p1 and p2->p3
-					normal = normal1;
-					lower = normal0;
-					upper = normal2;
-				} else {
-					// its on the inside (concave), so just use the normal of the segment
-					normal = normal1.getNegative();
-					lower = normal;
-					upper = normal;
-				}
-			} else if (convex1) {
-				//          O
-				//         /
-				//   O----O
-				//  /
-				// O 
-				// only p0->p1->p2 is convex
-				// is the center of the other shape on the convex side or the concave side?
-				boolean front = offset0 >= 0 || (offset1 >= 0 && offset2 >= 0);
-				if (front) {
-					// its on the convex side, the normal must be between the normals of
-					// p0->p1 and p1->p2
-					normal = normal1;
-					lower = normal0;
-					upper = normal1;
-				} else {
-					// its on the concave side, the normal must be between the normals of
-					// p1->p2 and p2->p3 on the convex side of p1->p2->p3
-					normal = normal1.getNegative();
-					lower = normal2.getNegative();
-					upper = normal1.getNegative();
-				}
-			} else if (convex2) {
-				// O
-				//  \
-				//   O----O
-				//         \
-				//          O
-				// only p1->p2->p3 is convex
-				// is the center of the other shape on the convex side or the concave side?
-				boolean front = offset2 >= 0 || (offset0 >= 0 && offset1 >= 0);
-				if (front) {
-					// its on the convex side, the normal must be in between the normals of
-					// p1->p2 and p2->p3
-					normal = normal1;
-					lower = normal1;
-					upper = normal2;
-				} else {
-					// its on the concave side, the normal must be between the normals of
-					// p0->p1 and p1->p2 on the convex side of p0->p1->p2
-					normal = normal1.getNegative();
-					lower = normal1.getNegative();
-					upper = normal0.getNegative();
-				}
-			} else {
-				// O        O
-				//  \      /
-				//   O----O
-				// otherwise both are convex
-				// is the center of the other shape on the convex or concave side?
-				boolean front = offset0 >= 0 && offset1 >= 0 && offset2 >= 0;
-				if (front) {
-					// its on the concave side, so just use the normal of the segment
-					normal = normal1;
-					lower = normal1;
-					upper = normal1;
-				} else {
-					// its on the convex side, so the normal must be between the normals of
-					// p0->p1 and p2->p3
-					normal = normal1.getNegative();
-					lower = normal2.getNegative();
-					upper = normal0.getNegative();
-				}
+		if (side <= 0) {
+			// test against the previous edge normal
+			if (prev == null) {
+				// if previous is null, then do normal 
+				// two-sided segment behavior
+				return;
 			}
-		} else if (p0 != null) {
-			// we only have a previous point
-			// does p0->p1->p2 make a convex feature?
-			if (convex1) {
-				//   O----O
-				//  /
-				// O
-				// is the center of the other shape on the convex or concave side?
-				boolean front = offset0 >= 0 || offset1 >= 0;
-				if (front) {
-					// its on the convex side, so the normal must be between the normals of
-					// p0->p1 and p1->p2 rotated -pi
-					normal = normal1;
-					lower = normal0;
-					upper = normal1.getNegative();
-				} else {
-					// its on the concave side, so the normal must be between the normals of
-					// p1->p2 and p1->p2 rotated -pi
-					normal = normal1.getNegative();
-					lower = normal1;
-					upper = normal1.getNegative();
+			
+			Vector2 prevEdge = prev.getEdgeVector();
+			prevEdge.normalize();
+			
+			// does the previous edge and this edge form a convex feature?
+			boolean isConvex = prevEdge.cross(edge) > 0;
+			if (isConvex) {
+				// check if the normal is outside the allowable range
+				double region = normal.cross(prevEdge.getLeftHandOrthogonalVector());
+				if (region > 0.0) {
+					// else skip
+					penetration.clear();
 				}
+				
+				// it's allowed as is
+			} else if (back < 0.0) {
+				// else skip
+				penetration.clear();
 			} else {
-				// O
-				//  \
-				//   O----O
-				// is the center of the other shape on the convex or concave side?
-				boolean front = offset0 >= 0 && offset1 >= 0;
-				if (front) {
-					// its on the concave side, so the normal must be between the normals of
-					// p1->p2 and p1->p2 rotated -pi
-					normal = normal1;
-					lower = normal1;
-					upper = normal1.getNegative();
-				} else {
-					// its on the convex side, so the normal must be between the normals of
-					// p1->p2 and p0->p1 rotated -pi
-					normal = normal1.getNegative();
-					lower = normal1;
-					upper = normal0.getNegative();
-				}
-			}
-		} else if (p3 != null) {
-			// we only have a next point
-			// does p1->p2->p3 make a convex feature?
-			if (convex2) {
-				// O----O
-				//       \
-				//        O
-				// is the center of the other shape on the convex or concave side?
-				boolean front = offset1 >= 0 || offset2 >= 0;
-				if (front) {
-					// its on the convex side, so the normal must be between the normals of
-					// p1->p2 rotated -pi and p2->p3
-					normal = normal1;
-					lower = normal1.getNegative();
-					upper = normal2;
-				} else {
-					// its on the concave side, so the normal must be between the normals of
-					// p1->p2 rotated -pi and p1->p2
-					normal = normal1.getNegative();
-					lower = normal1.getNegative();
-					upper = normal1;
-				}
-			} else {
-				//        O
-				//       /
-				// O----O
-				// is the center of the other shape on the convex or concave side?
-				boolean front = offset1 >= 0 && offset2 >= 0;
-				if (front) {
-					// its on the concave side, so the normal must be between the normals of
-					// p1->p2 rotated -pi and p1->p2
-					normal = normal1;
-					lower = normal1.getNegative();
-					upper = normal1;
-				} else {
-					// its on the convex side, so the normal must be between the normals of
-					// p2->p3 rotated -pi and p1->p2
-					normal = normal1.getNegative();
-					lower = normal2.getNegative();
-					upper = normal1;
-				}
+				// the previous edge and this edge form a concave feature
+				// for this case, it's always the edge normal
+				Vector2 norm = edgeNormal;
+				penetration.normal.x = norm.x;
+				penetration.normal.y = norm.y;
 			}
 		} else {
-			// otherwise we don't have any adjacency information
-			boolean front = offset1 >= 0;
-			if (front) {
-				normal = normal1;
-				lower = normal1.getNegative();
-				upper = normal1.getNegative();
+			// test against the next edge normal
+			if (next == null) {
+				// if next is null, then do normal 
+				// two-sided segment behavior
+				return;
+			}
+			
+			Vector2 nextEdge = next.getEdgeVector();
+			nextEdge.normalize();
+			
+			// does this edge and the next edge form a convex feature?
+			boolean isConvex = edge.cross(nextEdge) > 0;
+			if (isConvex) {
+				// check if the normal is outside the allowable range
+				double region = nextEdge.getLeftHandOrthogonalVector().cross(normal);
+				if (region > 0.0) {
+					// else skip
+					penetration.clear();
+				}
+				
+				// it's allowed as is
+			} else if (back < 0.0) {
+				// else skip
+				penetration.clear();
 			} else {
-				normal = normal1.getNegative();
-				lower = normal1;
-				upper = normal1;
+				// this edge and the next edge form a concave feature
+				// for this case, it's always the edge normal
+				Vector2 norm = edgeNormal;
+				penetration.normal.x = norm.x;
+				penetration.normal.y = norm.y;
 			}
 		}
 		
-		// determine which normal, the upper or the lower, we should rotate the
-		// collision normal towards
-		Vector2 perp = normal.getRightHandOrthogonalVector();
-		if (n.dot(perp) >= 0) {
-			// the normal can't be outside the upper
-			if (n.difference(upper).dot(normal) < 0){
-				// use the upper normal
-				penetration.normal.x = upper.x;
-				penetration.normal.y = upper.y;
-				// adjust the depth
-				penetration.depth = upper.dot(n) * penetration.depth;
-			}
-		} else {
-			// the normal can't be outside the lower
-			if (n.difference(lower).dot(normal) < 0) {
-				// use the lower normal
-				penetration.normal.x = lower.x;
-				penetration.normal.y = lower.y;
-				// adjust the depth
-				penetration.depth = lower.dot(n) * penetration.depth;
-			}
-		}
+		return;
 	}
 }
diff --git a/src/main/java/org/dyn4j/geometry/Segment.java b/src/main/java/org/dyn4j/geometry/Segment.java
index 88c1364..2b0a31c 100644
--- a/src/main/java/org/dyn4j/geometry/Segment.java
+++ b/src/main/java/org/dyn4j/geometry/Segment.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2020 William Bittle  http://www.dyn4j.org/
+ * Copyright (c) 2010-2021 William Bittle  http://www.dyn4j.org/
  * All rights reserved.
  * 
  * Redistribution and use in source and binary forms, with or without modification, are permitted 
@@ -35,7 +35,7 @@ import org.dyn4j.resources.Messages;
  * <p>
  * This class represents a line segment that is infinitely thin.
  * @author William Bittle
- * @version 3.4.0
+ * @version 4.2.0
  * @since 1.0.0
  */
 public class Segment extends AbstractShape implements Convex, Wound, Shape, Transformable, DataContainer {
@@ -789,4 +789,16 @@ public class Segment extends AbstractShape implements Convex, Wound, Shape, Tran
 		aabb.minY = minY;
 		aabb.maxY = maxY;
 	}
+	
+	/**
+	 * Returns a normalized edge vector for this segment pointing
+	 * from the first vertex to the second.
+	 * @return Vector2
+	 * @since 4.2.0
+	 */
+	public Vector2 getEdgeVector() {
+		Vector2 edge = this.vertices[0].to(this.vertices[1]);
+		edge.normalize();
+		return edge;
+	}
 }
diff --git a/src/main/java/org/dyn4j/world/AbstractCollisionWorld.java b/src/main/java/org/dyn4j/world/AbstractCollisionWorld.java
index b4732bd..de9056f 100644
--- a/src/main/java/org/dyn4j/world/AbstractCollisionWorld.java
+++ b/src/main/java/org/dyn4j/world/AbstractCollisionWorld.java
@@ -1277,6 +1277,13 @@ public abstract class AbstractCollisionWorld<T extends CollisionBody<E>, E exten
 				// perform post processing
 				if (AbstractCollisionWorld.this.narrowphasePostProcessor != null) {
 					AbstractCollisionWorld.this.narrowphasePostProcessor.process(convex1, transform1, convex2, transform2, penetration);
+					// should we continue processing this collision?
+					if (penetration.getDepth() == 0.0) {
+						// this happens when the process finds a collision that should not
+						// be handled. In most cases this will be when an object is sliding
+						// across a chain of segments (Links)
+						return collision;
+					}
 				}
 				
 				// notify of the narrow-phase collision
