diff --git a/src/main/software/amazon/event/ruler/ByteMachine.java b/src/main/software/amazon/event/ruler/ByteMachine.java
index be8af26..f067401 100644
--- a/src/main/software/amazon/event/ruler/ByteMachine.java
+++ b/src/main/software/amazon/event/ruler/ByteMachine.java
@@ -831,13 +831,12 @@ class ByteMachine {
         }
 
         // Scenario 2 where multiple transitions will later converge: equals_ignore_case lower and upper case paths.
-        // Parse the next Java character into lower and upper case multibyte representations. Check if there are
-        // multiple multibytes (paths) and that there exists a transition that both lead to.
+        // Parse the next Java character into lower and upper case representations. Check if there are multiple
+        // multibytes (paths) and that there exists a transition that both lead to.
         String value = extractNextJavaCharacterFromInputCharacters(characters, i);
         InputCharacter[] inputCharacters = getParser().parse(MatchType.EQUALS_IGNORE_CASE, value);
-        InputMultiByteSet inputMultiByteSet = InputMultiByteSet.cast(inputCharacters[0]);
-        ByteTransition transition = getTransition(byteState, inputMultiByteSet);
-        return inputMultiByteSet.getMultiBytes().size() > 1 && transition != null;
+        ByteTransition transition = getTransition(byteState, inputCharacters[0]);
+        return inputCharacters[0] instanceof InputMultiByteSet && transition != null;
     }
 
     private boolean isNextCharacterFirstByteOfMultiByte(InputCharacter[] characters, int i) {
diff --git a/src/main/software/amazon/event/ruler/input/EqualsIgnoreCaseParser.java b/src/main/software/amazon/event/ruler/input/EqualsIgnoreCaseParser.java
index fb0e0da..54a76c3 100644
--- a/src/main/software/amazon/event/ruler/input/EqualsIgnoreCaseParser.java
+++ b/src/main/software/amazon/event/ruler/input/EqualsIgnoreCaseParser.java
@@ -1,33 +1,42 @@
 package software.amazon.event.ruler.input;
 
 import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.HashSet;
+import java.util.List;
 import java.util.Locale;
 import java.util.Set;
 
 /**
- * A parser to be used specifically for equals-ignore-case rules.
+ * A parser to be used specifically for equals-ignore-case rules. For Java characters where lower and upper case UTF-8
+ * representations do not differ, we will parse into InputBytes. Otherwise, we will use InputMultiByteSet.
  *
  * Note that there are actually characters whose upper-case/lower-case UTF-8 representations differ in number of bytes.
  * One example where length differs by 1: ⱥ, Ⱥ
  * One example where length differs by 4: ΰ, Ϋ́
- * To deal with differing byte lengths per Java character, we will parse each Java character into an InputMultiByteSet.
+ * InputMultiByteSet handles differing byte lengths per Java character.
  */
-public class EqualsIgnoreCaseParser implements StringValueParser {
+public class EqualsIgnoreCaseParser {
 
     EqualsIgnoreCaseParser() { }
 
-    public InputCharacter[] parse(final String value) {
-        int i = 0;
-        final InputCharacter[] result = new InputCharacter[value.length()];
+    public InputCharacter[] parse(String value) {
+        List<InputCharacter> result = new ArrayList<>(value.length());
         for (char c : value.toCharArray()) {
-            byte[] lower = String.valueOf(c).toLowerCase(Locale.ROOT).getBytes(StandardCharsets.UTF_8);
-            byte[] upper = String.valueOf(c).toUpperCase(Locale.ROOT).getBytes(StandardCharsets.UTF_8);
-            Set<MultiByte> multi = new HashSet<>();
-            multi.add(new MultiByte(lower));
-            multi.add(new MultiByte(upper));
-            result[i++] = new InputMultiByteSet(multi);
+            byte[] lowerCaseUtf8bytes = String.valueOf(c).toLowerCase(Locale.ROOT).getBytes(StandardCharsets.UTF_8);
+            byte[] upperCaseUtf8bytes = String.valueOf(c).toUpperCase(Locale.ROOT).getBytes(StandardCharsets.UTF_8);
+            if (Arrays.equals(lowerCaseUtf8bytes, upperCaseUtf8bytes)) {
+                for (int i = 0; i < lowerCaseUtf8bytes.length; i++) {
+                    result.add(new InputByte(lowerCaseUtf8bytes[i]));
+                }
+            } else {
+                Set<MultiByte> multiBytes = new HashSet<>();
+                multiBytes.add(new MultiByte(lowerCaseUtf8bytes));
+                multiBytes.add(new MultiByte(upperCaseUtf8bytes));
+                result.add(new InputMultiByteSet(multiBytes));
+            }
         }
-        return result;
+        return result.toArray(new InputCharacter[0]);
     }
 }
\ No newline at end of file
