diff --git a/src/main/java/com/github/davidmoten/rx/internal/operators/OperatorBufferToFile.java b/src/main/java/com/github/davidmoten/rx/internal/operators/OperatorBufferToFile.java
index 3b01417..55f7cca 100644
--- a/src/main/java/com/github/davidmoten/rx/internal/operators/OperatorBufferToFile.java
+++ b/src/main/java/com/github/davidmoten/rx/internal/operators/OperatorBufferToFile.java
@@ -87,7 +87,6 @@ public final class OperatorBufferToFile<T> implements Operator<T, T> {
 		return parentSubscriber;
 	}
 
-
 	/**
 	 * Wraps a Queue (like MapDB Queue) to provide concurrency guarantees around
 	 * calls to the close() method. Extends AtomicBoolean to save allocation.
@@ -389,7 +388,7 @@ public final class OperatorBufferToFile<T> implements Operator<T, T> {
 						T item = queue.poll();
 						if (item == null) {
 							// queue is empty
-							if (finished(true)) {
+							if (finished()) {
 								return;
 							} else {
 								// another drain was requested so go
@@ -406,17 +405,21 @@ public final class OperatorBufferToFile<T> implements Operator<T, T> {
 						}
 					}
 				}
-				requests = addAndGet(-emitted);
-				if (requests == 0L && finished(queue.isEmpty())) {
+				// try and avoid the addAndGet if possible because it is
+				// more expensive than an emitted comparison
+				if (emitted != 0) {
+					requests = addAndGet(-emitted);
+				}
+				if (requests == 0L && finished()) {
 					return;
 				}
 			}
 		}
 
-		private boolean finished(boolean isQueueEmpty) {
+		private boolean finished() {
 			if (done) {
 				Throwable t = error;
-				if (isQueueEmpty) {
+				if (queue.isEmpty()) {
 					// first close the queue (which in this case though
 					// empty also disposes of its resources)
 					queue.unsubscribe();
diff --git a/src/main/java/com/github/davidmoten/rx/internal/operators/RollingSPSCQueue.java b/src/main/java/com/github/davidmoten/rx/internal/operators/RollingSPSCQueue.java
index 04e9cf9..9c92a93 100644
--- a/src/main/java/com/github/davidmoten/rx/internal/operators/RollingSPSCQueue.java
+++ b/src/main/java/com/github/davidmoten/rx/internal/operators/RollingSPSCQueue.java
@@ -90,8 +90,8 @@ final class RollingSPSCQueue<T> extends AtomicBoolean implements CloseableQueue<
 				// Queue2 references for gc early but would have to wait for an
 				// outstanding offer/poll/peek/isEmpty. This could make things a
 				// bit more complex and add overhead. Note that Queue2 instances
-				// after closing release their references to thier enclosed Queue
-				// references so going further to release Queue2 objects
+				// after closing release their references to thier enclosed
+				// Queue references so going further to release Queue2 objects
 				// themselves is not really worth it.
 			}
 		}
@@ -120,7 +120,9 @@ final class RollingSPSCQueue<T> extends AtomicBoolean implements CloseableQueue<
 					}
 				}
 			}
-			return queues.peekLast().offer(t);
+			synchronized (queues) {
+				return queues.peekLast().offer(t);
+			}
 		}
 	}
 
@@ -128,22 +130,30 @@ final class RollingSPSCQueue<T> extends AtomicBoolean implements CloseableQueue<
 	public T poll() {
 		// limited thread safety (offer/poll/close/peek/isEmpty concurrent but
 		// not poll and poll)
-		if (closed()) {
-			return null;
-		} else if (queues.isEmpty())
-			return null;
-		else {
-			while (true) {
+		while (true) {
+			if (closed()) {
+				return null;
+			}
+			synchronized (queues) {
 				Queue2<T> first = queues.peekFirst();
-				T value = first.poll();
+				if (first == null) {
+					return null;
+				}
+				T value;
+				value = first.poll();
 				if (value == null) {
 					if (first == queues.peekLast()) {
 						return null;
 					} else {
-						Queue2<T> removed = queues.pollFirst();
-						// don't have concurrent poll/poll so don't have to
+						Queue2<T> removed = null;
+						if (!closed()) {
+							removed = queues.pollFirst();
+						}
+						// don't have concurrent poll/poll so don't have
+						// to
 						// do null check on removed
-						removed.close();
+						if (removed != null)
+							removed.close();
 					}
 				} else {
 					return value;
@@ -158,17 +168,19 @@ final class RollingSPSCQueue<T> extends AtomicBoolean implements CloseableQueue<
 		if (closed()) {
 			return true;
 		} else {
-			Queue2<T> first = queues.peekFirst();
-			if (first == null) {
-				return true;
-			} else if (queues.peekLast() == first && first.isEmpty()) {
-				return true;
-			} else {
-				return false;
+			synchronized (queues) {
+				Queue2<T> first = queues.peekFirst();
+				if (first == null) {
+					return true;
+				} else if (queues.peekLast() == first && first.isEmpty()) {
+					return true;
+				} else {
+					return false;
+				}
 			}
 		}
 	}
-	
+
 	private boolean closed() {
 		return get();
 	}
diff --git a/src/main/java/rx/schedulers/ExecutorScheduler.java b/src/main/java/rx/schedulers/ExecutorScheduler.java
new file mode 100644
index 0000000..21e7508
--- /dev/null
+++ b/src/main/java/rx/schedulers/ExecutorScheduler.java
@@ -0,0 +1,189 @@
+/**
+ * Copyright 2014 Netflix, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy of
+ * the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package rx.schedulers;
+
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import rx.*;
+import rx.functions.Action0;
+import rx.internal.schedulers.*;
+import rx.plugins.RxJavaPlugins;
+import rx.subscriptions.*;
+
+/**
+ * Scheduler that wraps an Executor instance and establishes the Scheduler contract upon it.
+ * <p>
+ * Note that thread-hopping is unavoidable with this kind of Scheduler as we don't know about the underlying
+ * threading behavior of the executor.
+ */
+/* public */final class ExecutorScheduler extends Scheduler {
+    final Executor executor;
+    public ExecutorScheduler(Executor executor) {
+        this.executor = executor;
+    }
+
+    /**
+     * @warn javadoc missing
+     * @return
+     */
+    @Override
+    public Worker createWorker() {
+        return new ExecutorSchedulerWorker(executor);
+    }
+
+    /** Worker that schedules tasks on the executor indirectly through a trampoline mechanism. */
+    static final class ExecutorSchedulerWorker extends Scheduler.Worker implements Runnable {
+        final Executor executor;
+        // TODO: use a better performing structure for task tracking
+        final CompositeSubscription tasks;
+        // TODO: use MpscLinkedQueue once available
+        final ConcurrentLinkedQueue<ScheduledAction> queue; 
+        final AtomicInteger wip;
+        
+        final ScheduledExecutorService service;
+        
+        public ExecutorSchedulerWorker(Executor executor) {
+            this.executor = executor;
+            this.queue = new ConcurrentLinkedQueue<ScheduledAction>();
+            this.wip = new AtomicInteger();
+            this.tasks = new CompositeSubscription();
+            this.service = GenericScheduledExecutorService.getInstance();
+        }
+
+        @Override
+        public Subscription schedule(Action0 action) {
+            if (isUnsubscribed()) {
+                return Subscriptions.unsubscribed();
+            }
+            ScheduledAction ea = new ScheduledAction(action, tasks);
+            tasks.add(ea);
+            queue.offer(ea);
+            if (wip.getAndIncrement() == 0) {
+                try {
+                    // note that since we schedule the emission of potentially multiple tasks
+                    // there is no clear way to cancel this schedule from individual tasks
+                    // so even if executor is an ExecutorService, we can't associate the future
+                    // returned by submit() with any particular ScheduledAction
+                    executor.execute(this);
+                } catch (RejectedExecutionException t) {
+                    // cleanup if rejected
+                    tasks.remove(ea);
+                    wip.decrementAndGet();
+                    // report the error to the plugin
+                    RxJavaPlugins.getInstance().getErrorHandler().handleError(t);
+                    // throw it to the caller
+                    throw t;
+                }
+            }
+            
+            return ea;
+        }
+
+        @Override
+        public void run() {
+            do {
+                if (tasks.isUnsubscribed()) {
+                    queue.clear();
+                    return;
+                }
+                ScheduledAction sa = queue.poll();
+                if (sa == null) {
+                    return;
+                }
+                if (!sa.isUnsubscribed()) {
+                	if (!tasks.isUnsubscribed()) {
+                        sa.run();
+                	} else {
+                		queue.clear();
+                		return;
+                	}
+                }
+            } while (wip.decrementAndGet() != 0);
+        }
+        
+        @Override
+        public Subscription schedule(final Action0 action, long delayTime, TimeUnit unit) {
+            if (delayTime <= 0) {
+                return schedule(action);
+            }
+            if (isUnsubscribed()) {
+                return Subscriptions.unsubscribed();
+            }
+            
+            final MultipleAssignmentSubscription first = new MultipleAssignmentSubscription();
+            final MultipleAssignmentSubscription mas = new MultipleAssignmentSubscription();
+            mas.set(first);
+            tasks.add(mas);
+            final Subscription removeMas = Subscriptions.create(new Action0() {
+                @Override
+                public void call() {
+                    tasks.remove(mas);
+                }
+            });
+            
+            ScheduledAction ea = new ScheduledAction(new Action0() {
+                @Override
+                public void call() {
+                    if (mas.isUnsubscribed()) {
+                        return;
+                    }
+                    // schedule the real action untimed
+                    Subscription s2 = schedule(action);
+                    mas.set(s2);
+                    // unless the worker is unsubscribed, we should get a new ScheduledAction
+                    if (s2.getClass() == ScheduledAction.class) {
+                        // when this ScheduledAction completes, we need to remove the
+                        // MAS referencing the whole setup to avoid leaks
+                        ((ScheduledAction)s2).add(removeMas);
+                    }
+                }
+            });
+            // This will make sure if ea.call() gets executed before this line
+            // we don't override the current task in mas.
+            first.set(ea);
+            // we don't need to add ea to tasks because it will be tracked through mas/first
+            
+            
+            try {
+                Future<?> f = service.schedule(ea, delayTime, unit);
+                ea.add(f);
+            } catch (RejectedExecutionException t) {
+                // report the rejection to plugins
+                RxJavaPlugins.getInstance().getErrorHandler().handleError(t);
+                throw t;
+            }
+            
+            /*
+             * This allows cancelling either the delayed schedule or the actual schedule referenced
+             * by mas and makes sure mas is removed from the tasks composite to avoid leaks.
+             */
+            return removeMas;
+        }
+
+        @Override
+        public boolean isUnsubscribed() {
+            return tasks.isUnsubscribed();
+        }
+
+        @Override
+        public void unsubscribe() {
+            tasks.unsubscribe();
+            queue.clear();
+        }
+        
+    }
+}
